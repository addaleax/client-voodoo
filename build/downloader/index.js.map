{"version":3,"sources":["downloader/index.js","downloader/index.ts"],"names":["Downloader","Downloader.download","DownloadHandleState","DownloadHandle","DownloadHandle.constructor","DownloadHandle.start","DownloadHandle.stop","DownloadHandle.download","DownloadHandle.onProgress","DownloadHandle.onTick","DownloadHandle.onError","DownloadHandle.onFinished","DownloadHandle.from","DownloadHandle.to","DownloadHandle.peakKbps","DownloadHandle.lowKbps","DownloadHandle.avgKbps","DownloadHandle.currentKbps","DownloadHandle.currentAveragedSpeed","DownloadHandle.promise"],"mappings":"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","file":"downloader/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar http = require('http');\nvar url = require('url');\nvar path = require('path');\nvar events_1 = require('events');\nvar _ = require('lodash');\nlet decompressStream = require('iltorb').decompressStream;\nlet Bluebird = require('bluebird');\nvar mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsStat = Bluebird.promisify(fs.stat);\nclass Downloader {\n    static download(from, to, options) {\n        return new DownloadHandle(from, to, options);\n    }\n}\nexports.Downloader = Downloader;\n(function (DownloadHandleState) {\n    DownloadHandleState[DownloadHandleState[\"STARTED\"] = 0] = \"STARTED\";\n    DownloadHandleState[DownloadHandleState[\"STARTING\"] = 1] = \"STARTING\";\n    DownloadHandleState[DownloadHandleState[\"STOPPED\"] = 2] = \"STOPPED\";\n    DownloadHandleState[DownloadHandleState[\"STOPPING\"] = 3] = \"STOPPING\";\n    DownloadHandleState[DownloadHandleState[\"FINISHED\"] = 4] = \"FINISHED\";\n})(exports.DownloadHandleState || (exports.DownloadHandleState = {}));\nvar DownloadHandleState = exports.DownloadHandleState;\nconst TICKS_PER_SECOND = 2;\nclass DownloadHandle {\n    constructor(_from, _to, options) {\n        this._from = _from;\n        this._to = _to;\n        options = _.defaults(options || {}, {\n            brotli: true,\n        });\n        this._useBrotli = options.brotli;\n        this._state = DownloadHandleState.STOPPED;\n        this._emitter = new events_1.EventEmitter();\n        this.start();\n    }\n    get from() {\n        return this._from;\n    }\n    get to() {\n        return this._to;\n    }\n    get peakKbps() {\n        return this._peakSpeed / 1024 / TICKS_PER_SECOND;\n    }\n    get lowKbps() {\n        return this._lowSpeed / 1024 / TICKS_PER_SECOND;\n    }\n    get avgKbps() {\n        return this._avgSpeed / 1024 / TICKS_PER_SECOND;\n    }\n    get currentKbps() {\n        return this._curSpeed / 1024 / TICKS_PER_SECOND;\n    }\n    get currentAveragedSpeed() {\n        if (this._curSpeedTicks.length === 0) {\n            return this.currentKbps;\n        }\n        let sum = this._curSpeedTicks.reduce(function (accumulated, current) {\n            return accumulated + current / 1024 / TICKS_PER_SECOND;\n        }, 0);\n        return sum / this._curSpeedTicks.length;\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    start() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STOPPED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STARTING;\n            this._promise = this.promise; // Make sure a promise exists when starting.\n            this._peakSpeed = 0;\n            this._lowSpeed = 0;\n            this._avgSpeed = 0;\n            this._speedTicksCount = 0;\n            this._curSpeed = 0;\n            this._curSpeedTicks = [];\n            this._totalSize = 0;\n            this._totalDownloaded = 0;\n            try {\n                let parsedDownloadUrl = url.parse(this._from, true);\n                this._toFilename = path.parse(parsedDownloadUrl.pathname).base;\n                this._toFile = path.join(this._to, this._toFilename);\n                let exists = yield fsExists(this._toFile);\n                if (yield fsExists(this._toFile)) {\n                    let stat = yield fsStat(this._toFile);\n                    this._totalDownloaded = stat.size;\n                }\n                else if (!(yield mkdirp(this._to))) {\n                    throw new Error('Couldn\\'t create the destination folder path');\n                }\n            }\n            catch (err) {\n                this.onError(err);\n            }\n            this.download();\n            return true;\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STARTED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STOPPING;\n            clearInterval(this._curSpeedInterval);\n            this._response.removeAllListeners();\n            this._destStream.removeAllListeners();\n            this._response.unpipe(this._destStream);\n            this._destStream.close();\n            this._request.abort();\n            this._state = DownloadHandleState.STOPPED;\n            return true;\n        });\n    }\n    download() {\n        let hostUrl = url.parse(this._from);\n        let httpOptions = {\n            host: hostUrl.host,\n            path: hostUrl.path,\n            headers: {\n                'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n            }\n        };\n        this._destStream = fs.createWriteStream(this._toFile, {\n            encoding: 'binary',\n            flags: 'a',\n        });\n        this._request = http.request(httpOptions, (response) => {\n            this._response = response;\n            this._curSpeedInterval = setInterval(this.onTick.bind(this), 1000 / TICKS_PER_SECOND);\n            this._state = DownloadHandleState.STARTED;\n            // Unsatisfiable request - most likely we've downloaded the whole thing already.\n            // TODO - send HEAD request to get content-length and compare.\n            if (this._response.statusCode == 416) {\n                return this.onFinished();\n            }\n            // Expecting the partial response status code\n            if (this._response.statusCode != 206) {\n                return this.onError(new Error('Bad status code ' + this._response.statusCode));\n            }\n            if (!this._response.headers || !this._response.headers['content-range']) {\n                return this.onError(new Error('Missing or invalid content-range response header'));\n            }\n            try {\n                this._totalSize = parseInt(this._response.headers['content-range'].split('/')[1]);\n            }\n            catch (err) {\n                return this.onError(new Error('Invalid content-range header: ' + this._response.headers['content-range']));\n            }\n            this._response.setEncoding('binary');\n            // if ( this._useBrotli ) {\n            // \tthis._response\n            // \t\t.pipe( decompressStream() )\n            // \t\t.pipe( this._destStream );\n            // }\n            // else {\n            // \tthis._response.pipe( this._destStream );\n            // }\n            this._response.pipe(this._destStream);\n            this._response.on('data', (data) => {\n                this._totalDownloaded += data.length;\n                this._curSpeed += data.length;\n            });\n            this._destStream.on('finish', () => this.onFinished());\n            this._response.on('error', (err) => this.onError(err));\n            this._destStream.on('error', (err) => this.onError(err));\n        });\n        this._request.on('error', (err) => this.onError(err));\n        this._request.end();\n    }\n    onProgress(fn) {\n        this._emitter.addListener('progress', fn);\n        return this;\n    }\n    onTick() {\n        this._curSpeedTicks.unshift(this._curSpeed);\n        this._speedTicksCount += 1;\n        this._avgSpeed += (this._curSpeed - this._avgSpeed) / this._speedTicksCount;\n        this._peakSpeed = Math.max(this._peakSpeed, this._curSpeed);\n        this._lowSpeed = Math.min(this._lowSpeed || Infinity, this._curSpeed);\n        if (this._curSpeedTicks.length > 5 * TICKS_PER_SECOND) {\n            this._curSpeedTicks.pop();\n        }\n        this._emitter.emit('progress', {\n            progress: this._totalDownloaded / this._totalSize,\n            curKbps: this.currentKbps,\n            peakKbps: this.peakKbps,\n            lowKbps: this.lowKbps,\n            avgKbps: this.avgKbps,\n        });\n        this._curSpeed = 0;\n    }\n    onError(err) {\n        this.stop();\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this.stop();\n        this._state = DownloadHandleState.FINISHED;\n        this._resolver();\n    }\n}\n","import * as fs from 'fs';\nimport * as http from 'http';\nimport * as url from 'url';\nimport * as util from 'util';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\nimport * as _ from 'lodash';\n\nlet decompressStream = require('iltorb').decompressStream;\n\nlet Bluebird = require( 'bluebird' );\nvar mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsStat:( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\n\nexport interface  IDownloadOptions\n{\n\tbrotli?: boolean\n}\n\nexport abstract class Downloader\n{\n\tstatic download( from: string, to: string, options?: IDownloadOptions ): DownloadHandle\n\t{\n\t\treturn new DownloadHandle( from, to, options );\n\t}\n}\n\nexport enum DownloadHandleState\n{\n\tSTARTED,\n\tSTARTING,\n\tSTOPPED,\n\tSTOPPING,\n\tFINISHED,\n}\n\nexport interface DownloadProgress\n{\n\tprogress: number;\n\tcurKbps: number;\n\tpeakKbps: number;\n\tlowKbps: number;\n\tavgKbps: number;\n}\n\nconst TICKS_PER_SECOND = 2;\n\nclass DownloadHandle\n{\n\tprivate _state: DownloadHandleState;\n\tprivate _useBrotli: boolean;\n\tprivate _emitter: EventEmitter;\n\tprivate _toFile: string;\n\tprivate _toFilename: string;\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _peakSpeed: number;\n\tprivate _lowSpeed: number;\n\tprivate _avgSpeed: number;\n\tprivate _speedTicksCount: number;\n\tprivate _curSpeed: number;\n\tprivate _curSpeedTicks: Array<number>;\n\tprivate _curSpeedInterval: number;\n\tprivate _totalSize: number;\n\tprivate _totalDownloaded: number;\n\tprivate _destStream: fs.WriteStream;\n\tprivate _request: http.ClientRequest;\n\tprivate _response: http.IncomingMessage;\n\n\tconstructor( private _from: string, private _to: string, options: IDownloadOptions )\n\t{\n\t\toptions = _.defaults( options || {}, {\n\t\t\tbrotli: true,\n\t\t} );\n\n\t\tthis._useBrotli = options.brotli;\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\t\tthis._emitter = new EventEmitter();\n\t\tthis.start();\n\t}\n\n\tget from(): string\n\t{\n\t\treturn this._from;\n\t}\n\n\tget to(): string\n\t{\n\t\treturn this._to;\n\t}\n\n\tget peakKbps(): number\n\t{\n\t\treturn this._peakSpeed / 1024 / TICKS_PER_SECOND;\n\t}\n\n\tget lowKbps(): number\n\t{\n\t\treturn this._lowSpeed / 1024 / TICKS_PER_SECOND;\n\t}\n\n\tget avgKbps(): number\n\t{\n\t\treturn this._avgSpeed / 1024 / TICKS_PER_SECOND;\n\t}\n\n\tget currentKbps(): number\n\t{\n\t\treturn this._curSpeed / 1024 / TICKS_PER_SECOND;\n\t}\n\n\tget currentAveragedSpeed(): number\n\t{\n\t\tif ( this._curSpeedTicks.length === 0 ) {\n\t\t\treturn this.currentKbps;\n\t\t}\n\n\t\tlet sum = this._curSpeedTicks.reduce( function( accumulated, current )\n\t\t{\n\t\t\treturn accumulated + current / 1024 / TICKS_PER_SECOND;\n\t\t}, 0 );\n\n\t\treturn sum / this._curSpeedTicks.length;\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tasync start()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STOPPED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STARTING;\n\n\t\tthis._promise = this.promise; // Make sure a promise exists when starting.\n\n\t\tthis._peakSpeed = 0;\n\t\tthis._lowSpeed = 0;\n\t\tthis._avgSpeed = 0;\n\t\tthis._speedTicksCount = 0;\n\t\tthis._curSpeed = 0;\n\t\tthis._curSpeedTicks = [];\n\t\tthis._totalSize = 0;\n\t\tthis._totalDownloaded = 0;\n\n\t\ttry {\n\t\t\tlet parsedDownloadUrl = url.parse( this._from, true );\n\t\t\tthis._toFilename = path.parse( parsedDownloadUrl.pathname ).base;\n\t\t\tthis._toFile = path.join( this._to, this._toFilename );\n\t\t\tlet exists = await fsExists( this._toFile );\n\t\t\tif ( await fsExists( this._toFile ) ) {\n\t\t\t\tlet stat = await fsStat( this._toFile );\n\t\t\t\tthis._totalDownloaded = stat.size;\n\t\t\t}\n\t\t\telse if ( !( await mkdirp( this._to ) ) ) {\n\t\t\t\tthrow new Error( 'Couldn\\'t create the destination folder path' );\n\t\t\t}\n\t\t}\n\t\tcatch ( err ) {\n\t\t\tthis.onError( err );\n\t\t}\n\n\t\tthis.download();\n\t\treturn true;\n\t}\n\n\tasync stop()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STARTED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STOPPING;\n\n\t\tclearInterval( this._curSpeedInterval );\n\t\tthis._response.removeAllListeners();\n\t\tthis._destStream.removeAllListeners();\n\t\tthis._response.unpipe( this._destStream );\n\t\tthis._destStream.close();\n\t\tthis._request.abort();\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\n\t\treturn true;\n\t}\n\n\tprivate download()\n\t{\n\t\tlet hostUrl = url.parse( this._from );\n\t\tlet httpOptions = {\n\t\t\thost: hostUrl.host,\n\t\t\tpath: hostUrl.path,\n\t\t\theaders: {\n\t\t\t\t'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n\t\t\t}\n\t\t};\n\n\t\tthis._destStream = fs.createWriteStream( this._toFile, {\n\t\t\tencoding: 'binary',\n\t\t\tflags: 'a',\n\t\t} );\n\n\t\tthis._request = http.request( httpOptions, ( response ) =>\n\t\t{\n\t\t\tthis._response = response;\n\t\t\tthis._curSpeedInterval = setInterval( this.onTick.bind( this ), 1000 / TICKS_PER_SECOND );\n\t\t\tthis._state = DownloadHandleState.STARTED;\n\n\t\t\t// Unsatisfiable request - most likely we've downloaded the whole thing already.\n\t\t\t// TODO - send HEAD request to get content-length and compare.\n\t\t\tif ( this._response.statusCode == 416 ) {\n\t\t\t\treturn this.onFinished();\n\t\t\t}\n\n\t\t\t// Expecting the partial response status code\n\t\t\tif ( this._response.statusCode != 206 ) {\n\t\t\t\treturn this.onError( new Error( 'Bad status code ' + this._response.statusCode ) );\n\t\t\t}\n\n\t\t\tif ( !this._response.headers || !this._response.headers[ 'content-range' ] ) {\n\t\t\t\treturn this.onError( new Error( 'Missing or invalid content-range response header' ) );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._totalSize = parseInt( this._response.headers[ 'content-range' ].split( '/' )[1] );\n\t\t\t}\n\t\t\tcatch ( err ) {\n\t\t\t\treturn this.onError( new Error( 'Invalid content-range header: ' + this._response.headers[ 'content-range' ] ) );\n\t\t\t}\n\n\t\t\tthis._response.setEncoding( 'binary' );\n\t\t\t// if ( this._useBrotli ) {\n\t\t\t// \tthis._response\n\t\t\t// \t\t.pipe( decompressStream() )\n\t\t\t// \t\t.pipe( this._destStream );\n\t\t\t// }\n\t\t\t// else {\n\t\t\t// \tthis._response.pipe( this._destStream );\n\t\t\t// }\n\t\t\tthis._response.pipe( this._destStream );\n\t\t\tthis._response.on( 'data', ( data ) =>\n\t\t\t{\n\t\t\t\tthis._totalDownloaded += data.length;\n\t\t\t\tthis._curSpeed += data.length;\n\t\t\t} );\n\n\t\t\tthis._destStream.on( 'finish', () => this.onFinished() );\n\n\t\t\tthis._response.on( 'error', ( err ) => this.onError( err ) );\n\t\t\tthis._destStream.on( 'error', ( err ) => this.onError( err ) );\n\t\t} );\n\t\tthis._request.on( 'error', ( err ) => this.onError( err ) );\n\t\tthis._request.end();\n\t}\n\n\tonProgress( fn: ( DownloadProgress ) => void ): DownloadHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', fn );\n\t\treturn this;\n\t}\n\n\tprivate onTick()\n\t{\n\t\tthis._curSpeedTicks.unshift( this._curSpeed );\n\t\tthis._speedTicksCount += 1;\n\t\tthis._avgSpeed += ( this._curSpeed - this._avgSpeed ) / this._speedTicksCount;\n\t\tthis._peakSpeed = Math.max( this._peakSpeed, this._curSpeed );\n\t\tthis._lowSpeed = Math.min( this._lowSpeed || Infinity, this._curSpeed );\n\n\t\tif ( this._curSpeedTicks.length > 5 * TICKS_PER_SECOND ) { // Save only the 5 last seconds for average speed\n\t\t\tthis._curSpeedTicks.pop();\n\t\t}\n\n\t\tthis._emitter.emit( 'progress', {\n\t\t\tprogress: this._totalDownloaded / this._totalSize,\n\t\t\tcurKbps: this.currentKbps,\n\t\t\tpeakKbps: this.peakKbps,\n\t\t\tlowKbps: this.lowKbps,\n\t\t\tavgKbps: this.avgKbps,\n\t\t} );\n\t\tthis._curSpeed = 0;\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis.stop();\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis.stop();\n\t\tthis._state = DownloadHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}