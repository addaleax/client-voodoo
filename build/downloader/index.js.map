{"version":3,"sources":["downloader/index.js","downloader/index.ts"],"names":["Downloader","Downloader.download","DownloadHandleState","DownloadHandle","DownloadHandle.constructor","DownloadHandle.start","DownloadHandle.stop","DownloadHandle.download","DownloadHandle.onProgress","DownloadHandle.emitProgress","DownloadHandle.onError","DownloadHandle.onFinished","DownloadHandle.url","DownloadHandle.to","DownloadHandle.state","DownloadHandle.totalSize","DownloadHandle.totalDownloaded","DownloadHandle.promise"],"mappings":"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","file":"downloader/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar url = require('url');\nvar path = require('path');\nvar events_1 = require('events');\nvar _ = require('lodash');\nvar request = require('request');\nvar StreamSpeed = require('./stream-speed');\nvar common_1 = require('../common');\nclass Downloader {\n    static download(from, to, options) {\n        return new DownloadHandle(from, to, options);\n    }\n}\nexports.Downloader = Downloader;\n(function (DownloadHandleState) {\n    DownloadHandleState[DownloadHandleState[\"STARTED\"] = 0] = \"STARTED\";\n    DownloadHandleState[DownloadHandleState[\"STARTING\"] = 1] = \"STARTING\";\n    DownloadHandleState[DownloadHandleState[\"STOPPED\"] = 2] = \"STOPPED\";\n    DownloadHandleState[DownloadHandleState[\"STOPPING\"] = 3] = \"STOPPING\";\n    DownloadHandleState[DownloadHandleState[\"FINISHED\"] = 4] = \"FINISHED\";\n})(exports.DownloadHandleState || (exports.DownloadHandleState = {}));\nvar DownloadHandleState = exports.DownloadHandleState;\nclass DownloadHandle {\n    constructor(_url, _to, _options) {\n        this._url = _url;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            overwrite: false,\n        });\n        this._state = DownloadHandleState.STOPPED;\n        this._emitter = new events_1.EventEmitter();\n        this.start();\n    }\n    get url() {\n        return this._url;\n    }\n    get to() {\n        return this._to;\n    }\n    get state() {\n        return this._state;\n    }\n    get totalSize() {\n        return this._totalSize;\n    }\n    get totalDownloaded() {\n        return this._totalDownloaded;\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    start() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STOPPED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STARTING;\n            this._promise = this.promise; // Make sure a promise exists when starting.\n            this._totalSize = 0;\n            this._totalDownloaded = 0;\n            try {\n                // If the actual file already exists, we resume download.\n                if (yield common_1.default.fsExists(this._to)) {\n                    // Make sure the destination is a file.\n                    let stat = yield common_1.default.fsStat(this._to);\n                    if (!stat.isFile()) {\n                        throw new Error('Can\\'t resume downloading because the destination isn\\'t a file.');\n                    }\n                    else if (this._options.overwrite) {\n                        let unlinked = yield common_1.default.fsUnlink(this._to);\n                        if (unlinked) {\n                            throw new Error('Can\\'t download because destination cannot be overwritten.');\n                        }\n                        stat.size = 0;\n                    }\n                    this._totalDownloaded = stat.size;\n                }\n                else {\n                    let toDir = path.dirname(this._to);\n                    if (yield common_1.default.fsExists(toDir)) {\n                        let dirStat = yield common_1.default.fsStat(toDir);\n                        if (!dirStat.isDirectory()) {\n                            throw new Error('Can\\'t download to destination because the path is invalid.');\n                        }\n                    }\n                    else if (!(yield common_1.default.mkdirp(toDir))) {\n                        throw new Error('Couldn\\'t create the destination folder path');\n                    }\n                }\n                this._options.overwrite = false;\n            }\n            catch (err) {\n                this.onError(err);\n                return false;\n            }\n            this.download();\n            return true;\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STARTED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STOPPING;\n            this._streamSpeed.stop();\n            this._response.removeAllListeners();\n            this._destStream.removeAllListeners();\n            this._response.unpipe(this._destStream);\n            this._destStream.close();\n            this._request.abort();\n            this._state = DownloadHandleState.STOPPED;\n            return true;\n        });\n    }\n    download() {\n        let hostUrl = url.parse(this._url);\n        let httpOptions = {\n            headers: {\n                'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n            },\n        };\n        this._destStream = fs.createWriteStream(this._to, {\n            flags: 'a',\n        });\n        this._request = request.get(this._url, httpOptions)\n            .on('response', (response) => {\n            if (response.statusCode === 301) {\n                return;\n            }\n            this._response = response;\n            this._streamSpeed = new StreamSpeed.StreamSpeed(this._options);\n            this._streamSpeed.onSample((sample) => this.emitProgress({\n                progress: this._totalDownloaded / this._totalSize,\n                timeLeft: Math.round((this._totalSize - this._totalDownloaded) / sample.currentAverage),\n                sample: sample,\n            }));\n            this._state = DownloadHandleState.STARTED;\n            // Unsatisfiable request - most likely we've downloaded the whole thing already.\n            // TODO - send HEAD request to get content-length and compare.\n            if (this._response.statusCode === 416) {\n                return this.onFinished();\n            }\n            // Expecting the partial response status code\n            if (this._response.statusCode !== 206) {\n                return this.onError(new Error('Bad status code ' + this._response.statusCode));\n            }\n            if (!this._response.headers || !this._response.headers['content-range']) {\n                return this.onError(new Error('Missing or invalid content-range response header'));\n            }\n            try {\n                this._totalSize = parseInt(this._response.headers['content-range'].split('/')[1]);\n            }\n            catch (err) {\n                return this.onError(new Error('Invalid content-range header: ' + this._response.headers['content-range']));\n            }\n            if (this._options.decompressStream) {\n                this._request\n                    .pipe(this._streamSpeed)\n                    .pipe(this._options.decompressStream)\n                    .pipe(this._destStream);\n            }\n            else {\n                this._request\n                    .pipe(this._streamSpeed)\n                    .pipe(this._destStream);\n            }\n            this._destStream.on('finish', () => this.onFinished());\n            this._destStream.on('error', (err) => this.onError(err));\n        })\n            .on('data', (data) => {\n            this._totalDownloaded += data.length;\n        })\n            .on('error', (err) => this.onError(err));\n        // \tthis._response.on( 'data', ( data ) =>\n        // \t{\n        // \t\tthis._totalDownloaded += data.length;\n        // \t} );\n        // \tthis._destStream.on( 'finish', () => this.onFinished() );\n        // \tthis._response.on( 'error', ( err ) => this.onError( err ) );\n        // \tthis._destStream.on( 'error', ( err ) => this.onError( err ) );\n        // } );\n        // this._request.on( 'error', ( err ) => this.onError( err ) );\n        // this._request.end();\n    }\n    onProgress(unit, fn) {\n        this._emitter.addListener('progress', (progress) => {\n            progress.sample = StreamSpeed.StreamSpeed.convertSample(progress.sample, unit);\n            fn(progress);\n        });\n        return this;\n    }\n    emitProgress(progress) {\n        this._emitter.emit('progress', progress);\n    }\n    onError(err) {\n        this.stop();\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this.stop();\n        this._state = DownloadHandleState.FINISHED;\n        this._resolver();\n    }\n}\nexports.DownloadHandle = DownloadHandle;\n","import * as fs from 'fs';\nimport * as http from 'http';\nimport * as url from 'url';\nimport * as util from 'util';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\nimport * as _ from 'lodash';\nimport { Transform } from 'stream';\nimport * as request from 'request';\nimport * as StreamSpeed from './stream-speed';\nimport Common from '../common';\n\nexport interface IDownloadOptions extends StreamSpeed.IStreamSpeedOptions\n{\n\toverwrite?: boolean;\n\tdecompressStream?: Transform;\n}\n\nexport abstract class Downloader\n{\n\tstatic download( from: string, to: string, options?: IDownloadOptions ): DownloadHandle\n\t{\n\t\treturn new DownloadHandle( from, to, options );\n\t}\n}\n\nexport enum DownloadHandleState\n{\n\tSTARTED,\n\tSTARTING,\n\tSTOPPED,\n\tSTOPPING,\n\tFINISHED,\n}\n\nexport interface IDownloadProgress\n{\n\tprogress: number;\n\ttimeLeft: number;\n\tsample: StreamSpeed.ISampleData;\n}\n\nexport class DownloadHandle\n{\n\tprivate _state: DownloadHandleState;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tprivate _totalSize: number;\n\tprivate _totalDownloaded: number;\n\n\tprivate _streamSpeed: StreamSpeed.StreamSpeed;\n\tprivate _destStream: fs.WriteStream;\n\tprivate _request: request.Request;\n\tprivate _response: http.IncomingMessage;\n\n\tconstructor( private _url: string, private _to: string, private _options: IDownloadOptions )\n\t{\n\t\tthis._options = _.defaults( this._options || {}, {\n\t\t\toverwrite: false,\n\t\t} );\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\t\tthis._emitter = new EventEmitter();\n\t\tthis.start();\n\t}\n\n\tget url()\n\t{\n\t\treturn this._url;\n\t}\n\n\tget to()\n\t{\n\t\treturn this._to;\n\t}\n\n\tget state()\n\t{\n\t\treturn this._state;\n\t}\n\n\tget totalSize()\n\t{\n\t\treturn this._totalSize;\n\t}\n\n\tget totalDownloaded()\n\t{\n\t\treturn this._totalDownloaded;\n\t}\n\n\tget promise()\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tasync start()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STOPPED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STARTING;\n\t\tthis._promise = this.promise; // Make sure a promise exists when starting.\n\n\t\tthis._totalSize = 0;\n\t\tthis._totalDownloaded = 0;\n\n\t\ttry {\n\n\t\t\t// If the actual file already exists, we resume download.\n\t\t\tif ( await Common.fsExists( this._to ) ) {\n\n\t\t\t\t// Make sure the destination is a file.\n\t\t\t\tlet stat = await Common.fsStat( this._to );\n\t\t\t\tif ( !stat.isFile() ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t resume downloading because the destination isn\\'t a file.' );\n\t\t\t\t}\n\t\t\t\telse if ( this._options.overwrite ) {\n\t\t\t\t\tlet unlinked = await Common.fsUnlink( this._to );\n\t\t\t\t\tif ( unlinked ) {\n\t\t\t\t\t\tthrow new Error( 'Can\\'t download because destination cannot be overwritten.' );\n\t\t\t\t\t}\n\t\t\t\t\tstat.size = 0;\n\t\t\t\t}\n\t\t\t\tthis._totalDownloaded = stat.size;\n\t\t\t}\n\t\t\t// Otherwise, we validate the folder path.\n\t\t\telse {\n\t\t\t\tlet toDir = path.dirname( this._to );\n\t\t\t\tif ( await Common.fsExists( toDir ) ) {\n\t\t\t\t\tlet dirStat = await Common.fsStat( toDir );\n\t\t\t\t\tif ( !dirStat.isDirectory() ) {\n\t\t\t\t\t\tthrow new Error( 'Can\\'t download to destination because the path is invalid.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create the folder path.\n\t\t\t\telse if ( !( await Common.mkdirp( toDir ) ) ) {\n\t\t\t\t\tthrow new Error( 'Couldn\\'t create the destination folder path' );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._options.overwrite = false;\n\t\t}\n\t\tcatch ( err ) {\n\t\t\tthis.onError( err );\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.download();\n\t\treturn true;\n\t}\n\n\tasync stop()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STARTED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STOPPING;\n\n\t\tthis._streamSpeed.stop();\n\t\tthis._response.removeAllListeners();\n\t\tthis._destStream.removeAllListeners();\n\t\tthis._response.unpipe( this._destStream );\n\t\tthis._destStream.close();\n\t\tthis._request.abort();\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\n\t\treturn true;\n\t}\n\n\tprivate download()\n\t{\n\t\tlet hostUrl = url.parse( this._url );\n\t\tlet httpOptions: request.CoreOptions = {\n\t\t\theaders: {\n\t\t\t\t'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n\t\t\t},\n\t\t};\n\n\t\tthis._destStream = fs.createWriteStream( this._to, {\n\t\t\tflags: 'a',\n\t\t} );\n\n\t\tthis._request = request.get( this._url, httpOptions )\n\t\t\t.on( 'response', ( response: http.IncomingMessage ) =>\n\t\t\t{\n\t\t\t\tif ( response.statusCode === 301 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._response = response;\n\n\t\t\t\tthis._streamSpeed = new StreamSpeed.StreamSpeed( this._options );\n\t\t\t\tthis._streamSpeed.onSample( ( sample ) => this.emitProgress( {\n\t\t\t\t\tprogress: this._totalDownloaded / this._totalSize,\n\t\t\t\t\ttimeLeft: Math.round( ( this._totalSize - this._totalDownloaded ) / sample.currentAverage ),\n\t\t\t\t\tsample: sample,\n\t\t\t\t} ) );\n\t\t\t\tthis._state = DownloadHandleState.STARTED;\n\n\t\t\t\t// Unsatisfiable request - most likely we've downloaded the whole thing already.\n\t\t\t\t// TODO - send HEAD request to get content-length and compare.\n\t\t\t\tif ( this._response.statusCode === 416 ) {\n\t\t\t\t\treturn this.onFinished();\n\t\t\t\t}\n\n\t\t\t\t// Expecting the partial response status code\n\t\t\t\tif ( this._response.statusCode !== 206 ) {\n\t\t\t\t\treturn this.onError( new Error( 'Bad status code ' + this._response.statusCode ) );\n\t\t\t\t}\n\n\t\t\t\tif ( !this._response.headers || !this._response.headers[ 'content-range' ] ) {\n\t\t\t\t\treturn this.onError( new Error( 'Missing or invalid content-range response header' ) );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tthis._totalSize = parseInt( this._response.headers[ 'content-range' ].split( '/' )[1] );\n\t\t\t\t}\n\t\t\t\tcatch ( err ) {\n\t\t\t\t\treturn this.onError( new Error( 'Invalid content-range header: ' + this._response.headers[ 'content-range' ] ) );\n\t\t\t\t}\n\n\t\t\t\tif ( this._options.decompressStream ) {\n\t\t\t\t\tthis._request\n\t\t\t\t\t\t.pipe( this._streamSpeed )\n\t\t\t\t\t\t.pipe( this._options.decompressStream )\n\t\t\t\t\t\t.pipe( this._destStream );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._request\n\t\t\t\t\t\t.pipe( this._streamSpeed )\n\t\t\t\t\t\t.pipe( this._destStream );\n\t\t\t\t}\n\n\t\t\t\tthis._destStream.on( 'finish', () => this.onFinished() );\n\t\t\t\tthis._destStream.on( 'error', ( err ) => this.onError( err ) );\n\t\t\t} )\n\t\t\t.on( 'data', ( data ) =>\n\t\t\t{\n\t\t\t\tthis._totalDownloaded += data.length;\n\t\t \t} )\n\t\t\t.on( 'error', ( err ) => this.onError( err ) );\n\n\t\t// \tthis._response.on( 'data', ( data ) =>\n\t\t// \t{\n\t\t// \t\tthis._totalDownloaded += data.length;\n\t\t// \t} );\n\n\t\t// \tthis._destStream.on( 'finish', () => this.onFinished() );\n\n\t\t// \tthis._response.on( 'error', ( err ) => this.onError( err ) );\n\t\t// \tthis._destStream.on( 'error', ( err ) => this.onError( err ) );\n\t\t// } );\n\t\t// this._request.on( 'error', ( err ) => this.onError( err ) );\n\t\t// this._request.end();\n\t}\n\n\tonProgress( unit: StreamSpeed.SampleUnit, fn: ( progress: IDownloadProgress ) => void ): DownloadHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', ( progress: IDownloadProgress ) =>\n\t\t{\n\t\t\tprogress.sample =  StreamSpeed.StreamSpeed.convertSample( progress.sample, unit );\n\t\t\tfn( progress );\n\t\t} );\n\t\treturn this;\n\t}\n\n\tprivate emitProgress( progress: IDownloadProgress )\n\t{\n\t\tthis._emitter.emit( 'progress', progress );\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis.stop();\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis.stop();\n\t\tthis._state = DownloadHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}