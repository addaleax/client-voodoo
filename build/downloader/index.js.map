{"version":3,"sources":["downloader/index.js","downloader/index.ts"],"names":["Downloader","Downloader.download","DownloadHandleState","DownloadHandle","DownloadHandle.constructor","DownloadHandle.start","DownloadHandle.stop","DownloadHandle.download","DownloadHandle.onProgress","DownloadHandle.emitProgress","DownloadHandle.onError","DownloadHandle.onFinished","DownloadHandle.from","DownloadHandle.to","DownloadHandle.toFilename","DownloadHandle.toFullpath","DownloadHandle.promise"],"mappings":"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","file":"downloader/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar http = require('http');\nvar url = require('url');\nvar path = require('path');\nvar events_1 = require('events');\nvar _ = require('lodash');\nvar StreamSpeed = require('./stream-speed');\nlet decompressStream = require('iltorb').decompressStream;\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsStat = Bluebird.promisify(fs.stat);\nclass Downloader {\n    static download(from, to, options) {\n        return new DownloadHandle(from, to, options);\n    }\n}\nexports.Downloader = Downloader;\n(function (DownloadHandleState) {\n    DownloadHandleState[DownloadHandleState[\"STARTED\"] = 0] = \"STARTED\";\n    DownloadHandleState[DownloadHandleState[\"STARTING\"] = 1] = \"STARTING\";\n    DownloadHandleState[DownloadHandleState[\"STOPPED\"] = 2] = \"STOPPED\";\n    DownloadHandleState[DownloadHandleState[\"STOPPING\"] = 3] = \"STOPPING\";\n    DownloadHandleState[DownloadHandleState[\"FINISHED\"] = 4] = \"FINISHED\";\n})(exports.DownloadHandleState || (exports.DownloadHandleState = {}));\nvar DownloadHandleState = exports.DownloadHandleState;\nclass DownloadHandle {\n    constructor(_from, _to, _options) {\n        this._from = _from;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(_options || {}, {\n            brotli: true,\n            overwrite: false,\n            destIsFolder: true,\n        });\n        this._state = DownloadHandleState.STOPPED;\n        this._emitter = new events_1.EventEmitter();\n        this.start();\n    }\n    get from() {\n        return this._from;\n    }\n    get to() {\n        return this._to;\n    }\n    get toFilename() {\n        return this._toFilename;\n    }\n    get toFullpath() {\n        return this._toFile;\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    start() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STOPPED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STARTING;\n            this._promise = this.promise; // Make sure a promise exists when starting.\n            this._totalSize = 0;\n            this._totalDownloaded = 0;\n            try {\n                if (this._options.destIsFolder) {\n                    let parsedDownloadUrl = url.parse(this._from, true);\n                    this._toFilename = path.basename(parsedDownloadUrl.pathname);\n                }\n                else {\n                    this._toFilename = path.basename(this._to);\n                    this._to = path.dirname(this._to);\n                }\n                this._toFile = path.join(this._to, this._toFilename);\n                // If the actual file already exists, we resume download.\n                if (yield fsExists(this._toFile)) {\n                    // Make sure the destination is a file.\n                    let stat = yield fsStat(this._toFile);\n                    if (!stat.isFile()) {\n                        throw new Error('Can\\'t resume downloading because the destination isn\\'t a file.');\n                    }\n                    else if (this._options.overwrite) {\n                        let unlinked = yield fsUnlink(this._toFile);\n                        if (unlinked) {\n                            throw new Error('Can\\'t download because destination cannot be overwritten.');\n                        }\n                        this._options.overwrite = false;\n                        stat.size = 0;\n                    }\n                    this._totalDownloaded = stat.size;\n                }\n                else {\n                    if (yield fsExists(this._to)) {\n                        let dirStat = yield fsStat(this._to);\n                        if (!dirStat.isDirectory()) {\n                            throw new Error('Can\\'t download to destination because the path is invalid.');\n                        }\n                    }\n                    else if (!(yield mkdirp(this._to))) {\n                        throw new Error('Couldn\\'t create the destination folder path');\n                    }\n                }\n            }\n            catch (err) {\n                this.onError(err);\n            }\n            this.download();\n            return true;\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== DownloadHandleState.STARTED) {\n                return false;\n            }\n            this._state = DownloadHandleState.STOPPING;\n            this._streamSpeed.stop();\n            this._response.removeAllListeners();\n            this._destStream.removeAllListeners();\n            this._response.unpipe(this._destStream);\n            this._destStream.close();\n            this._request.abort();\n            this._state = DownloadHandleState.STOPPED;\n            return true;\n        });\n    }\n    download() {\n        let hostUrl = url.parse(this._from);\n        let httpOptions = {\n            host: hostUrl.host,\n            path: hostUrl.path,\n            headers: {\n                'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n            }\n        };\n        this._destStream = fs.createWriteStream(this._toFile, {\n            flags: 'a',\n        });\n        this._request = http.request(httpOptions, (response) => {\n            this._response = response;\n            this._streamSpeed = new StreamSpeed.StreamSpeed(this._options);\n            this._streamSpeed.onSample((sample) => this.emitProgress({\n                progress: this._totalDownloaded / this._totalSize,\n                sample: sample,\n            }));\n            this._state = DownloadHandleState.STARTED;\n            // Unsatisfiable request - most likely we've downloaded the whole thing already.\n            // TODO - send HEAD request to get content-length and compare.\n            if (this._response.statusCode == 416) {\n                return this.onFinished();\n            }\n            // Expecting the partial response status code\n            if (this._response.statusCode != 206) {\n                return this.onError(new Error('Bad status code ' + this._response.statusCode));\n            }\n            if (!this._response.headers || !this._response.headers['content-range']) {\n                return this.onError(new Error('Missing or invalid content-range response header'));\n            }\n            try {\n                this._totalSize = parseInt(this._response.headers['content-range'].split('/')[1]);\n            }\n            catch (err) {\n                return this.onError(new Error('Invalid content-range header: ' + this._response.headers['content-range']));\n            }\n            if (this._options.brotli) {\n                this._response\n                    .pipe(this._streamSpeed)\n                    .pipe(decompressStream())\n                    .pipe(this._destStream);\n            }\n            else {\n                this._response\n                    .pipe(this._streamSpeed)\n                    .pipe(this._destStream);\n            }\n            this._response.on('data', (data) => {\n                this._totalDownloaded += data.length;\n            });\n            this._destStream.on('finish', () => this.onFinished());\n            this._response.on('error', (err) => this.onError(err));\n            this._destStream.on('error', (err) => this.onError(err));\n        });\n        this._request.on('error', (err) => this.onError(err));\n        this._request.end();\n    }\n    onProgress(unit, fn) {\n        this._emitter.addListener('progress', (progress) => {\n            progress.sample = StreamSpeed.StreamSpeed.convertSample(progress.sample, unit);\n            fn(progress);\n        });\n        return this;\n    }\n    emitProgress(progress) {\n        this._emitter.emit('progress', progress);\n    }\n    onError(err) {\n        this.stop();\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this.stop();\n        this._state = DownloadHandleState.FINISHED;\n        this._resolver();\n    }\n}\nexports.DownloadHandle = DownloadHandle;\n","import * as fs from 'fs';\nimport * as http from 'http';\nimport * as url from 'url';\nimport * as util from 'util';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\nimport * as _ from 'lodash';\nimport * as StreamSpeed from './stream-speed';\n\nlet decompressStream = require( 'iltorb' ).decompressStream;\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsStat:( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\n\nexport interface IDownloadOptions extends StreamSpeed.IStreamSpeedOptions\n{\n\tbrotli?: boolean;\n\toverwrite?: boolean;\n\tdestIsFolder?: boolean\n}\n\nexport abstract class Downloader\n{\n\tstatic download( from: string, to: string, options?: IDownloadOptions ): DownloadHandle\n\t{\n\t\treturn new DownloadHandle( from, to, options );\n\t}\n}\n\nexport enum DownloadHandleState\n{\n\tSTARTED,\n\tSTARTING,\n\tSTOPPED,\n\tSTOPPING,\n\tFINISHED,\n}\n\nexport interface IDownloadProgress\n{\n\tprogress: number;\n\tsample: StreamSpeed.ISampleData;\n}\n\nexport class DownloadHandle\n{\n\tprivate _state: DownloadHandleState;\n\n\tprivate _toFile: string;\n\tprivate _toFilename: string;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tprivate _totalSize: number;\n\tprivate _totalDownloaded: number;\n\n\tprivate _streamSpeed: StreamSpeed.StreamSpeed;\n\tprivate _destStream: fs.WriteStream;\n\tprivate _request: http.ClientRequest;\n\tprivate _response: http.IncomingMessage;\n\n\tconstructor( private _from: string, private _to: string, private _options: IDownloadOptions )\n\t{\n\t\tthis._options = _.defaults( _options || {}, {\n\t\t\tbrotli: true,\n\t\t\toverwrite: false,\n\t\t\tdestIsFolder: true,\n\t\t} );\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\t\tthis._emitter = new EventEmitter();\n\t\tthis.start();\n\t}\n\n\tget from(): string\n\t{\n\t\treturn this._from;\n\t}\n\n\tget to(): string\n\t{\n\t\treturn this._to;\n\t}\n\n\tget toFilename(): string\n\t{\n\t\treturn this._toFilename;\n\t}\n\n\tget toFullpath(): string\n\t{\n\t\treturn this._toFile;\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tasync start()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STOPPED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STARTING;\n\t\tthis._promise = this.promise; // Make sure a promise exists when starting.\n\n\t\tthis._totalSize = 0;\n\t\tthis._totalDownloaded = 0;\n\n\t\ttry {\n\t\t\tif ( this._options.destIsFolder ) {\n\t\t\t\tlet parsedDownloadUrl = url.parse( this._from, true );\n\t\t\t\tthis._toFilename = path.basename( parsedDownloadUrl.pathname );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._toFilename = path.basename( this._to );\n\t\t\t\tthis._to = path.dirname( this._to );\n\t\t\t}\n\t\t\tthis._toFile = path.join( this._to, this._toFilename );\n\n\t\t\t// If the actual file already exists, we resume download.\n\t\t\tif ( await fsExists( this._toFile ) ) {\n\n\t\t\t\t// Make sure the destination is a file.\n\t\t\t\tlet stat = await fsStat( this._toFile );\n\t\t\t\tif ( !stat.isFile() ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t resume downloading because the destination isn\\'t a file.' );\n\t\t\t\t}\n\t\t\t\telse if ( this._options.overwrite ) {\n\t\t\t\t\tlet unlinked = await fsUnlink( this._toFile );\n\t\t\t\t\tif ( unlinked ) {\n\t\t\t\t\t\tthrow new Error( 'Can\\'t download because destination cannot be overwritten.' );\n\t\t\t\t\t}\n\t\t\t\t\tthis._options.overwrite = false;\n\t\t\t\t\tstat.size = 0;\n\t\t\t\t}\n\t\t\t\tthis._totalDownloaded = stat.size;\n\t\t\t}\n\t\t\t// Otherwise, we validate the folder path.\n\t\t\telse {\n\t\t\t\tif ( await fsExists( this._to ) ) {\n\t\t\t\t\tlet dirStat = await fsStat( this._to );\n\t\t\t\t\tif ( !dirStat.isDirectory() ) {\n\t\t\t\t\t\tthrow new Error( 'Can\\'t download to destination because the path is invalid.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create the folder path.\n\t\t\t\telse if ( !( await mkdirp( this._to ) ) ) {\n\t\t\t\t\tthrow new Error( 'Couldn\\'t create the destination folder path' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch ( err ) {\n\t\t\tthis.onError( err );\n\t\t}\n\n\t\tthis.download();\n\t\treturn true;\n\t}\n\n\tasync stop()\n\t{\n\t\tif ( this._state !== DownloadHandleState.STARTED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = DownloadHandleState.STOPPING;\n\n\t\tthis._streamSpeed.stop();\n\t\tthis._response.removeAllListeners();\n\t\tthis._destStream.removeAllListeners();\n\t\tthis._response.unpipe( this._destStream );\n\t\tthis._destStream.close();\n\t\tthis._request.abort();\n\n\t\tthis._state = DownloadHandleState.STOPPED;\n\n\t\treturn true;\n\t}\n\n\tprivate download()\n\t{\n\t\tlet hostUrl = url.parse( this._from );\n\t\tlet httpOptions = {\n\t\t\thost: hostUrl.host,\n\t\t\tpath: hostUrl.path,\n\t\t\theaders: {\n\t\t\t\t'Range': 'bytes=' + this._totalDownloaded.toString() + '-',\n\t\t\t}\n\t\t};\n\n\t\tthis._destStream = fs.createWriteStream( this._toFile, {\n\t\t\tflags: 'a',\n\t\t} );\n\n\t\tthis._request = http.request( httpOptions, ( response ) =>\n\t\t{\n\t\t\tthis._response = response;\n\t\t\tthis._streamSpeed = new StreamSpeed.StreamSpeed( this._options );\n\t\t\tthis._streamSpeed.onSample( ( sample ) => this.emitProgress( {\n\t\t\t\tprogress: this._totalDownloaded / this._totalSize,\n\t\t\t\tsample: sample,\n\t\t\t} ) );\n\t\t\tthis._state = DownloadHandleState.STARTED;\n\n\t\t\t// Unsatisfiable request - most likely we've downloaded the whole thing already.\n\t\t\t// TODO - send HEAD request to get content-length and compare.\n\t\t\tif ( this._response.statusCode == 416 ) {\n\t\t\t\treturn this.onFinished();\n\t\t\t}\n\n\t\t\t// Expecting the partial response status code\n\t\t\tif ( this._response.statusCode != 206 ) {\n\t\t\t\treturn this.onError( new Error( 'Bad status code ' + this._response.statusCode ) );\n\t\t\t}\n\n\t\t\tif ( !this._response.headers || !this._response.headers[ 'content-range' ] ) {\n\t\t\t\treturn this.onError( new Error( 'Missing or invalid content-range response header' ) );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tthis._totalSize = parseInt( this._response.headers[ 'content-range' ].split( '/' )[1] );\n\t\t\t}\n\t\t\tcatch ( err ) {\n\t\t\t\treturn this.onError( new Error( 'Invalid content-range header: ' + this._response.headers[ 'content-range' ] ) );\n\t\t\t}\n\n\t\t\tif ( this._options.brotli ) {\n\t\t\t\tthis._response\n\t\t\t\t\t.pipe( this._streamSpeed )\n\t\t\t\t\t.pipe( decompressStream() )\n\t\t\t\t\t.pipe( this._destStream );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._response\n\t\t\t\t\t.pipe( this._streamSpeed )\n\t\t\t\t\t.pipe( this._destStream );\n\t\t\t}\n\n\t\t\tthis._response.on( 'data', ( data ) =>\n\t\t\t{\n\t\t\t\tthis._totalDownloaded += data.length;\n\t\t\t} );\n\n\t\t\tthis._destStream.on( 'finish', () => this.onFinished() );\n\n\t\t\tthis._response.on( 'error', ( err ) => this.onError( err ) );\n\t\t\tthis._destStream.on( 'error', ( err ) => this.onError( err ) );\n\t\t} );\n\t\tthis._request.on( 'error', ( err ) => this.onError( err ) );\n\t\tthis._request.end();\n\t}\n\n\tonProgress( unit: StreamSpeed.SampleUnit, fn: ( progress: IDownloadProgress ) => void ): DownloadHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', ( progress: IDownloadProgress ) =>\n\t\t{\n\t\t\tprogress.sample =  StreamSpeed.StreamSpeed.convertSample( progress.sample, unit );\n\t\t\tfn( progress );\n\t\t} );\n\t\treturn this;\n\t}\n\n\tprivate emitProgress( progress: IDownloadProgress )\n\t{\n\t\tthis._emitter.emit( 'progress', progress );\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis.stop();\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis.stop();\n\t\tthis._state = DownloadHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}