{"version":3,"sources":["extractor/index.js","extractor/index.ts"],"names":["Extractor","Extractor.extract"],"mappings":"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","file":"extractor/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar tar = require('tar-fs');\nlet decompressStream = require('iltorb').decompressStream;\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nclass Extractor {\n    static extract(from, to, options) {\n        return __awaiter(this, void 0, Promise, function* () {\n            options = _.defaults(options || {}, {\n                deleteSource: false,\n                brotli: true,\n                overwrite: false,\n            });\n            // If the destination already exists, make sure its valid.\n            let destExists = yield fsExists(to);\n            if (destExists) {\n                let destStat = yield fsStat(to);\n                if (!destStat.isDirectory()) {\n                    throw new Error('Can\\'t extract to destination because its not a valid directory');\n                }\n                // Don't extract to a non-empty directory.\n                let filesInDest = yield fsReadDir(to);\n                if (filesInDest && filesInDest.length > 0) {\n                    // Allow extracting to a non empty directory only if the overwrite option is set.\n                    if (!options.overwrite) {\n                        throw new Error('Can\\'t extract to destination because it isnt empty');\n                    }\n                }\n            }\n            else if (!(yield mkdirp(to))) {\n                throw new Error('Couldn\\'t create destination folder path');\n            }\n            let result = yield new Promise((resolve, reject) => {\n                let stream = fs.createReadStream(from);\n                let extractStream = tar.extract(to);\n                extractStream.on('finish', () => resolve(true));\n                extractStream.on('error', (err) => reject(err));\n                stream.on('error', (err) => reject(err));\n                if (options.brotli) {\n                    stream\n                        .pipe(decompressStream())\n                        .pipe(extractStream);\n                }\n                else {\n                    stream.pipe(extractStream);\n                }\n            });\n            if (result && options.deleteSource) {\n                // Remove the source file, but throw only if there was an error and the file still exists.\n                let unlinked = yield fsUnlink(from);\n                if (unlinked && (yield fsExists(from))) {\n                    throw unlinked;\n                }\n            }\n            return result;\n        });\n    }\n}\nexports.Extractor = Extractor;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-fs';\n\nlet decompressStream = require( 'iltorb' ).decompressStream;\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsStat:( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\n\nexport interface IExtractOptions\n{\n\tdeleteSource?: boolean\n\tbrotli?: boolean\n\toverwrite?: boolean;\n}\n\nexport abstract class Extractor\n{\n\tstatic async extract( from: string, to: string, options?: IExtractOptions ): Promise<boolean>\n\t{\n\t\toptions = _.defaults( options || {}, {\n\t\t\tdeleteSource: false,\n\t\t\tbrotli: true,\n\t\t\toverwrite: false,\n\t\t} );\n\n\t\t// If the destination already exists, make sure its valid.\n\t\tlet destExists = await fsExists( to );\n\t\tif ( destExists ) {\n\t\t\tlet destStat = await fsStat( to );\n\t\t\tif ( !destStat.isDirectory() ) {\n\t\t\t\tthrow new Error( 'Can\\'t extract to destination because its not a valid directory' );\n\t\t\t}\n\n\t\t\t// Don't extract to a non-empty directory.\n\t\t\tlet filesInDest = await fsReadDir( to );\n\t\t\tif ( filesInDest && filesInDest.length > 0 ) {\n\n\t\t\t\t// Allow extracting to a non empty directory only if the overwrite option is set.\n\t\t\t\tif ( !options.overwrite ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t extract to destination because it isnt empty' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Create the folder path to extract to.\n\t\telse if ( !( await mkdirp( to ) ) ) {\n\t\t\tthrow new Error( 'Couldn\\'t create destination folder path' );\n\t\t}\n\n\t\tlet result = await new Promise<boolean>( ( resolve, reject ) =>\n\t\t{\n\t\t\tlet stream = fs.createReadStream( from )\n\t\t\tlet extractStream = tar.extract( to );\n\n\t\t\textractStream.on( 'finish', () => resolve( true ) );\n\t\t\textractStream.on( 'error', ( err ) => reject( err ) );\n\t\t\tstream.on( 'error', ( err ) => reject( err ) );\n\n\t\t\tif ( options.brotli ) {\n\t\t\t\tstream\n\t\t\t\t\t.pipe( decompressStream() )\n\t\t\t\t\t.pipe( extractStream );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstream.pipe( extractStream );\n\t\t\t}\n\t\t} );\n\n\t\tif ( result && options.deleteSource ) {\n\n\t\t\t// Remove the source file, but throw only if there was an error and the file still exists.\n\t\t\tlet unlinked = await fsUnlink( from );\n\t\t\tif ( unlinked && ( await fsExists( from ) ) ) {\n\t\t\t\tthrow unlinked;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],"sourceRoot":"../../src/"}