{"version":3,"sources":["extractor/index.js","extractor/index.ts"],"names":["Extractor","Extractor.extract","ExtractHandle","ExtractHandle.constructor","ExtractHandle.start","ExtractHandle.from","ExtractHandle.to","ExtractHandle.promise"],"mappings":"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","file":"extractor/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar tarFS = require('tar-fs');\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nclass Extractor {\n    static extract(from, to, options) {\n        return new ExtractHandle(from, to, options);\n    }\n}\nexports.Extractor = Extractor;\nclass ExtractHandle {\n    constructor(_from, _to, _options) {\n        this._from = _from;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            deleteSource: false,\n            overwrite: false,\n        });\n        this._promise = this.start();\n    }\n    get from() {\n        return this._from;\n    }\n    get to() {\n        return this._to;\n    }\n    get promise() {\n        return this._promise;\n    }\n    start() {\n        return __awaiter(this, void 0, Promise, function* () {\n            // If the destination already exists, make sure its valid.\n            if (yield fsExists(this._to)) {\n                let destStat = yield fsStat(this._to);\n                if (!destStat.isDirectory()) {\n                    throw new Error('Can\\'t extract to destination because its not a valid directory');\n                }\n                // Don't extract to a non-empty directory.\n                let filesInDest = yield fsReadDir(this._to);\n                if (filesInDest && filesInDest.length > 0) {\n                    // Allow extracting to a non empty directory only if the overwrite option is set.\n                    if (!this._options.overwrite) {\n                        throw new Error('Can\\'t extract to destination because it isnt empty');\n                    }\n                }\n            }\n            else if (!(yield mkdirp(this._to))) {\n                throw new Error('Couldn\\'t create destination folder path');\n            }\n            let files = [];\n            let result = yield new Promise((resolve, reject) => {\n                let stream = fs.createReadStream(this._from);\n                let optionsMap = this._options.map;\n                let extractStream = tarFS.extract(this._to, _.assign(this._options, {\n                    map: (header) => {\n                        // TODO: fuggin symlinks and the likes.\n                        if (header.type === 'file') {\n                            files.push(header.name);\n                        }\n                        if (optionsMap) {\n                            return optionsMap(header);\n                        }\n                        return header;\n                    },\n                }));\n                extractStream.on('finish', () => resolve(true));\n                extractStream.on('error', (err) => reject(err));\n                stream.on('error', (err) => reject(err));\n                if (this._options.decompressStream) {\n                    stream\n                        .pipe(this._options.decompressStream)\n                        .pipe(extractStream);\n                }\n                else {\n                    stream.pipe(extractStream);\n                }\n            });\n            if (result && this._options.deleteSource) {\n                // Remove the source file, but throw only if there was an error and the file still exists.\n                let unlinked = yield fsUnlink(this._from);\n                if (unlinked && (yield fsExists(this._from))) {\n                    throw unlinked;\n                }\n            }\n            return {\n                success: result,\n                files: files,\n            };\n        });\n    }\n}\nexports.ExtractHandle = ExtractHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-stream';\nimport * as tarFS from 'tar-fs';\nimport { Readable, Transform } from 'stream';\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsStat:( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\n\nexport interface IExtractOptions extends tarFS.IExtractOptions\n{\n\tdeleteSource?: boolean;\n\toverwrite?: boolean;\n\tdecompressStream?: Transform;\n}\n\nexport interface IExtractResult\n{\n\tsuccess: boolean;\n\tfiles: string[];\n}\n\nexport abstract class Extractor\n{\n\tstatic extract( from: string, to: string, options?: IExtractOptions ): ExtractHandle\n\t{\n\t\treturn new ExtractHandle( from, to, options );\n\t}\n}\n\nexport class ExtractHandle\n{\n\tprivate _promise: Promise<IExtractResult>;\n\n\tconstructor( private _from: string, private _to: string, private _options?: IExtractOptions )\n\t{\n\t\tthis._options = _.defaults( this._options || {}, {\n\t\t\tdeleteSource: false,\n\t\t\toverwrite: false,\n\t\t} );\n\n\t\tthis._promise = this.start();\n\t}\n\n\tget from(): string\n\t{\n\t\treturn this._from;\n\t}\n\n\tget to(): string\n\t{\n\t\treturn this._to;\n\t}\n\n\tget promise(): Promise<IExtractResult>\n\t{\n\t\treturn this._promise;\n\t}\n\n\tprivate async start(): Promise<IExtractResult>\n\t{\n\t\t// If the destination already exists, make sure its valid.\n\t\tif ( await fsExists( this._to ) ) {\n\t\t\tlet destStat = await fsStat( this._to );\n\t\t\tif ( !destStat.isDirectory() ) {\n\t\t\t\tthrow new Error( 'Can\\'t extract to destination because its not a valid directory' );\n\t\t\t}\n\n\t\t\t// Don't extract to a non-empty directory.\n\t\t\tlet filesInDest = await fsReadDir( this._to );\n\t\t\tif ( filesInDest && filesInDest.length > 0 ) {\n\n\t\t\t\t// Allow extracting to a non empty directory only if the overwrite option is set.\n\t\t\t\tif ( !this._options.overwrite ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t extract to destination because it isnt empty' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Create the folder path to extract to.\n\t\telse if ( !( await mkdirp( this._to ) ) ) {\n\t\t\tthrow new Error( 'Couldn\\'t create destination folder path' );\n\t\t}\n\n\t\tlet files: string[] = [];\n\t\tlet result = await new Promise<boolean>( ( resolve, reject ) =>\n\t\t{\n\t\t\tlet stream = fs.createReadStream( this._from )\n\t\t\tlet optionsMap = this._options.map;\n\t\t\tlet extractStream = tarFS.extract( this._to, _.assign( this._options, {\n\t\t\t\tmap: ( header: tar.IEntryHeader ) =>\n\t\t\t\t{\n\t\t\t\t\t// TODO: fuggin symlinks and the likes.\n\t\t\t\t\tif ( header.type === 'file' ) {\n\t\t\t\t\t\tfiles.push( header.name );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( optionsMap ) {\n\t\t\t\t\t\treturn optionsMap( header );\n\t\t\t\t\t}\n\t\t\t\t\treturn header;\n\t\t\t\t},\n\t\t\t} ) );\n\n\t\t\textractStream.on( 'finish', () => resolve( true ) );\n\t\t\textractStream.on( 'error', ( err ) => reject( err ) );\n\t\t\tstream.on( 'error', ( err ) => reject( err ) );\n\n\t\t\tif ( this._options.decompressStream ) {\n\t\t\t\tstream\n\t\t\t\t\t.pipe( this._options.decompressStream )\n\t\t\t\t\t.pipe( extractStream );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstream.pipe( extractStream );\n\t\t\t}\n\t\t} );\n\n\t\tif ( result && this._options.deleteSource ) {\n\n\t\t\t// Remove the source file, but throw only if there was an error and the file still exists.\n\t\t\tlet unlinked = await fsUnlink( this._from );\n\t\t\tif ( unlinked && ( await fsExists( this._from ) ) ) {\n\t\t\t\tthrow unlinked;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: result,\n\t\t\tfiles: files,\n\t\t};\n\t}\n}\n"],"sourceRoot":"../../src/"}