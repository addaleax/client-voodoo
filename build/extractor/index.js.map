{"version":3,"sources":["extractor/index.js","extractor/index.ts"],"names":["Extractor","Extractor.extract","ExtractHandle","ExtractHandle.constructor","ExtractHandle.start","ExtractHandle._pipe","ExtractHandle._unpipe","ExtractHandle.stop","ExtractHandle.from","ExtractHandle.to","ExtractHandle.promise"],"mappings":"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","file":"extractor/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar tarFS = require('tar-fs');\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nclass Extractor {\n    static extract(from, to, options) {\n        return new ExtractHandle(from, to, options);\n    }\n}\nexports.Extractor = Extractor;\nclass ExtractHandle {\n    constructor(_from, _to, _options) {\n        this._from = _from;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            deleteSource: false,\n            overwrite: false,\n        });\n        // Avoid fat arrow here because it causes an implicit return and will resolve the promise.\n        let _this = this;\n        this._promise = new Promise(function (resolve, reject) {\n            _this.start().then((result) => {\n                if (!_this._terminated) {\n                    resolve(result);\n                }\n            });\n        });\n    }\n    get from() {\n        return this._from;\n    }\n    get to() {\n        return this._to;\n    }\n    get promise() {\n        return this._promise;\n    }\n    start() {\n        return __awaiter(this, void 0, Promise, function* () {\n            console.log('Starting extraction');\n            if (this._running) {\n                return this._promise;\n            }\n            else if (this._readStream) {\n                console.log('Resuming extraction');\n                this._pipe();\n                this._readStream.resume();\n                return this._promise;\n            }\n            this._running = true;\n            // If the destination already exists, make sure its valid.\n            if (yield fsExists(this._to)) {\n                let destStat = yield fsStat(this._to);\n                if (!destStat.isDirectory()) {\n                    throw new Error('Can\\'t extract to destination because its not a valid directory');\n                }\n                // Don't extract to a non-empty directory.\n                let filesInDest = yield fsReadDir(this._to);\n                if (filesInDest && filesInDest.length > 0) {\n                    // Allow extracting to a non empty directory only if the overwrite option is set.\n                    if (!this._options.overwrite) {\n                        throw new Error('Can\\'t extract to destination because it isnt empty');\n                    }\n                }\n            }\n            else if (!(yield mkdirp(this._to))) {\n                throw new Error('Couldn\\'t create destination folder path');\n            }\n            if (this._terminated) {\n                return {\n                    success: false,\n                    files: [],\n                };\n            }\n            let files = [];\n            let result = yield new Promise((resolve, reject) => {\n                this._readStream = fs.createReadStream(this._from);\n                this._resolver = resolve;\n                this._rejector = reject;\n                // If stopped between starting and here, the stop wouldn't have registered this read stream. So just do it now.\n                if (!this._running) {\n                    this.stop(false);\n                }\n                let optionsMap = this._options.map;\n                this._extractStream = tarFS.extract(this._to, _.assign(this._options, {\n                    map: (header) => {\n                        // TODO: fuggin symlinks and the likes.\n                        if (header.type === 'file') {\n                            console.log('Extracting ' + header.name);\n                            files.push(header.name);\n                        }\n                        if (optionsMap) {\n                            return optionsMap(header);\n                        }\n                        return header;\n                    },\n                }));\n                this._extractStream.on('finish', () => this._resolver(true));\n                this._extractStream.on('error', (err) => this._rejector(err));\n                if (this._options.decompressStream) {\n                    this._options.decompressStream.pipe(this._extractStream);\n                }\n                this._pipe();\n            });\n            if (result && this._options.deleteSource) {\n                // Remove the source file, but throw only if there was an error and the file still exists.\n                let unlinked = yield fsUnlink(this._from);\n                if (unlinked && (yield fsExists(this._from))) {\n                    throw unlinked;\n                }\n            }\n            return {\n                success: result,\n                files: files,\n            };\n        });\n    }\n    _pipe() {\n        this._readStream.on('error', (err) => this._rejector(err));\n        if (this._options.decompressStream) {\n            this._readStream.pipe(this._options.decompressStream);\n        }\n        else {\n            this._readStream.pipe(this._extractStream);\n        }\n    }\n    _unpipe() {\n        this._readStream.unpipe();\n        this._readStream.removeAllListeners();\n    }\n    stop(terminate) {\n        return __awaiter(this, void 0, Promise, function* () {\n            console.log('Extractor stopping');\n            this._running = false;\n            if (terminate) {\n                this._terminated = true;\n                let readStreamHack = this._readStream;\n                readStreamHack.destroy(); // Hack to get ts to stop bugging me. Its an undocumented function on readable streams\n            }\n            else {\n                console.log('Readable stream paused, should not read more files damnit!');\n                this._readStream.pause();\n                this._unpipe();\n            }\n            console.log('Extractor stopped');\n            return true;\n        });\n    }\n}\nexports.ExtractHandle = ExtractHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-stream';\nimport * as tarFS from 'tar-fs';\nimport { Readable, Transform } from 'stream';\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsStat:( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\n\nexport interface IExtractOptions extends tarFS.IExtractOptions\n{\n\tdeleteSource?: boolean;\n\toverwrite?: boolean;\n\tdecompressStream?: Transform;\n}\n\nexport interface IExtractResult\n{\n\tsuccess: boolean;\n\tfiles: string[];\n}\n\nexport abstract class Extractor\n{\n\tstatic extract( from: string, to: string, options?: IExtractOptions ): ExtractHandle\n\t{\n\t\treturn new ExtractHandle( from, to, options );\n\t}\n}\n\nexport class ExtractHandle\n{\n\tprivate _promise: Promise<IExtractResult>;\n\tprivate _resolver: Function;\n\tprivate _rejector: Function;\n\tprivate _readStream: Readable;\n\tprivate _extractStream: tar.Extract;\n\tprivate _running: boolean;\n\tprivate _terminated: boolean;\n\n\tconstructor( private _from: string, private _to: string, private _options?: IExtractOptions )\n\t{\n\t\tthis._options = _.defaults( this._options || {}, {\n\t\t\tdeleteSource: false,\n\t\t\toverwrite: false,\n\t\t} );\n\n\t\t// Avoid fat arrow here because it causes an implicit return and will resolve the promise.\n\t\tlet _this = this;\n\t\tthis._promise = new Promise<IExtractResult>( function( resolve, reject )\n\t\t{\n\t\t\t_this.start().then( ( result ) =>\n\t\t\t{\n\t\t\t\tif ( !_this._terminated ) {\n\t\t\t\t\tresolve( result );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\tget from(): string\n\t{\n\t\treturn this._from;\n\t}\n\n\tget to(): string\n\t{\n\t\treturn this._to;\n\t}\n\n\tget promise(): Promise<IExtractResult>\n\t{\n\t\treturn this._promise;\n\t}\n\n\tasync start(): Promise<IExtractResult>\n\t{\n\t\tconsole.log( 'Starting extraction' );\n\t\tif ( this._running ) {\n\t\t\treturn this._promise;\n\t\t}\n\t\telse if ( this._readStream ) {\n\t\t\tconsole.log( 'Resuming extraction' );\n\t\t\tthis._pipe();\n\t\t\tthis._readStream.resume();\n\t\t\treturn this._promise;\n\t\t}\n\n\t\tthis._running = true;\n\n\t\t// If the destination already exists, make sure its valid.\n\t\tif ( await fsExists( this._to ) ) {\n\t\t\tlet destStat = await fsStat( this._to );\n\t\t\tif ( !destStat.isDirectory() ) {\n\t\t\t\tthrow new Error( 'Can\\'t extract to destination because its not a valid directory' );\n\t\t\t}\n\n\t\t\t// Don't extract to a non-empty directory.\n\t\t\tlet filesInDest = await fsReadDir( this._to );\n\t\t\tif ( filesInDest && filesInDest.length > 0 ) {\n\n\t\t\t\t// Allow extracting to a non empty directory only if the overwrite option is set.\n\t\t\t\tif ( !this._options.overwrite ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t extract to destination because it isnt empty' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Create the folder path to extract to.\n\t\telse if ( !( await mkdirp( this._to ) ) ) {\n\t\t\tthrow new Error( 'Couldn\\'t create destination folder path' );\n\t\t}\n\n\t\tif ( this._terminated ) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tfiles: [],\n\t\t\t};\n\t\t}\n\n\t\tlet files: string[] = [];\n\t\tlet result = await new Promise<boolean>( ( resolve, reject ) =>\n\t\t{\n\t\t\tthis._readStream = fs.createReadStream( this._from );\n\t\t\tthis._resolver = resolve;\n\t\t\tthis._rejector = reject;\n\n\t\t\t// If stopped between starting and here, the stop wouldn't have registered this read stream. So just do it now.\n\t\t\tif ( !this._running ) {\n\t\t\t\tthis.stop( false );\n\t\t\t}\n\n\t\t\tlet optionsMap = this._options.map;\n\t\t\tthis._extractStream = tarFS.extract( this._to, _.assign( this._options, {\n\t\t\t\tmap: ( header: tar.IEntryHeader ) =>\n\t\t\t\t{\n\t\t\t\t\t// TODO: fuggin symlinks and the likes.\n\t\t\t\t\tif ( header.type === 'file' ) {\n\t\t\t\t\t\tconsole.log( 'Extracting ' + header.name );\n\t\t\t\t\t\tfiles.push( header.name );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( optionsMap ) {\n\t\t\t\t\t\treturn optionsMap( header );\n\t\t\t\t\t}\n\t\t\t\t\treturn header;\n\t\t\t\t},\n\t\t\t} ) );\n\n\t\t\tthis._extractStream.on( 'finish', () => this._resolver( true ) );\n\t\t\tthis._extractStream.on( 'error', ( err ) => this._rejector( err ) );\n\t\t\tif ( this._options.decompressStream ) {\n\t\t\t\tthis._options.decompressStream.pipe( this._extractStream );\n\t\t\t}\n\n\t\t\tthis._pipe();\n\t\t} );\n\n\t\tif ( result && this._options.deleteSource ) {\n\n\t\t\t// Remove the source file, but throw only if there was an error and the file still exists.\n\t\t\tlet unlinked = await fsUnlink( this._from );\n\t\t\tif ( unlinked && ( await fsExists( this._from ) ) ) {\n\t\t\t\tthrow unlinked;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: result,\n\t\t\tfiles: files,\n\t\t};\n\t}\n\n\tprivate _pipe()\n\t{\n\t\tthis._readStream.on( 'error', ( err ) => this._rejector( err ) );\n\n\t\tif ( this._options.decompressStream ) {\n\t\t\tthis._readStream.pipe( this._options.decompressStream )\n\t\t}\n\t\telse {\n\t\t\tthis._readStream.pipe( this._extractStream );\n\t\t}\n\t}\n\n\tprivate _unpipe()\n\t{\n\t\tthis._readStream.unpipe();\n\t\tthis._readStream.removeAllListeners();\n\t}\n\n\tasync stop( terminate?: boolean )\n\t{\n\t\tconsole.log( 'Extractor stopping' );\n\t\tthis._running = false;\n\t\tif ( terminate ) {\n\t\t\tthis._terminated = true;\n\t\t\tlet readStreamHack: any = this._readStream;\n\t\t\treadStreamHack.destroy(); // Hack to get ts to stop bugging me. Its an undocumented function on readable streams\n\t\t}\n\t\telse {\n\t\t\tconsole.log( 'Readable stream paused, should not read more files damnit!' );\n\t\t\tthis._readStream.pause();\n\t\t\tthis._unpipe();\n\t\t}\n\t\tconsole.log( 'Extractor stopped' );\n\t\treturn true;\n\t}\n}\n"],"sourceRoot":"../../src/"}