{"version":3,"sources":["patcher/index.js","patcher/index.ts"],"names":["PatchHandleState","Patcher","Patcher.patch","PatchHandle","PatchHandle.constructor","PatchHandle.patch","PatchHandle.onError","PatchHandle.onFinished","PatchHandle.promise"],"mappings":"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","file":"patcher/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar path = require('path');\nvar events_1 = require('events');\nvar extractor_1 = require('../extractor');\nlet decompressStream = require('iltorb').decompressStream;\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsReadFile = Bluebird.promisify(fs.readFile);\nlet fsWriteFile = Bluebird.promisify(fs.writeFile);\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nlet fsReadDirRecursively = Bluebird.promisify(require('recursive-readdir'));\n(function (PatchHandleState) {\n    PatchHandleState[PatchHandleState[\"STOPPED\"] = 0] = \"STOPPED\";\n    PatchHandleState[PatchHandleState[\"PATCHING\"] = 1] = \"PATCHING\";\n    PatchHandleState[PatchHandleState[\"FINISHED\"] = 2] = \"FINISHED\";\n})(exports.PatchHandleState || (exports.PatchHandleState = {}));\nvar PatchHandleState = exports.PatchHandleState;\nclass Patcher {\n    static patch(from, to, options) {\n        return new PatchHandle(from, to, options);\n    }\n}\nexports.Patcher = Patcher;\nclass PatchHandle {\n    constructor(_from, _to, _options) {\n        this._from = _from;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            brotli: true,\n        });\n        this._state = PatchHandleState.STOPPED;\n        this._emitter = new events_1.EventEmitter();\n        this._promise = this.promise;\n        this.patch()\n            .then(() => this.onFinished())\n            .catch((err) => this.onError(err));\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    patch() {\n        return __awaiter(this, void 0, Promise, function* () {\n            // TODO: restrict operations to the given directories.\n            this._state = PatchHandleState.PATCHING;\n            let currentFiles;\n            if (!(yield fsExists(this._to)) || !(yield fsStat(this._to)).isDirectory()) {\n                currentFiles = [];\n            }\n            else {\n                // TODO: check if ./ is valid on windows platforms as well.\n                currentFiles = (yield fsReadDirRecursively(this._to)).map((file) => './' + path.relative(this._to, file));\n            }\n            // If the destination already exists, make sure its valid.\n            let exists = yield fsExists(this._options.archiveListFile);\n            if (yield fsExists(this._options.archiveListFile)) {\n                // Make sure the destination is a file.\n                let stat = yield fsStat(this._options.archiveListFile);\n                if (!stat.isFile()) {\n                    throw new Error('Can\\'t patch because the archive file list isn\\'t a file.');\n                }\n            }\n            else {\n                let archiveListFileDir = path.dirname(this._options.archiveListFile);\n                if (yield fsExists(archiveListFileDir)) {\n                    let dirStat = yield fsStat(archiveListFileDir);\n                    if (!dirStat.isDirectory()) {\n                        throw new Error('Can\\'t patch because the path to the archive file list is invalid.');\n                    }\n                }\n                else if (!(yield mkdirp(archiveListFileDir))) {\n                    throw new Error('Couldn\\'t create the patch archive file list folder path');\n                }\n            }\n            let oldBuildFiles;\n            if (!(yield fsExists(this._options.archiveListFile))) {\n                oldBuildFiles = currentFiles;\n            }\n            else {\n                oldBuildFiles = (yield fsReadFile(this._options.archiveListFile, 'utf8')).split(\"\\n\");\n            }\n            let extractResult = yield extractor_1.Extractor.extract(this._from, this._to, {\n                brotli: this._options.brotli,\n                overwrite: true,\n                deleteSource: true,\n            }).promise;\n            if (!extractResult.success) {\n                throw new Error('Failed to extract patch file');\n            }\n            let newBuildFiles = extractResult.files;\n            // Files that the old build created are files in the file system that are not listed in the old build files\n            let createdByOldBuild = _.difference(currentFiles, oldBuildFiles);\n            // Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n            let filesToRemove = _.difference(currentFiles, newBuildFiles, createdByOldBuild);\n            // TODO: use del lib\n            let unlinks = yield Promise.all(filesToRemove.map((file) => {\n                return fsUnlink(path.resolve(this._to, file)).then(function (err) {\n                    if (err) {\n                        throw err;\n                    }\n                    return true;\n                });\n            }));\n            yield fsWriteFile(this._options.archiveListFile, newBuildFiles.join(\"\\n\"));\n            return true;\n        });\n    }\n    onError(err) {\n        this._state = PatchHandleState.STOPPED;\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this._state = PatchHandleState.FINISHED;\n        this._resolver();\n    }\n}\nexports.PatchHandle = PatchHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-fs';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\n\nimport * as StreamSpeed from '../downloader/stream-speed';\nimport { Downloader, DownloadHandle, IDownloadProgress } from '../downloader';\nimport { Extractor } from '../extractor';\n\nlet decompressStream = require( 'iltorb' ).decompressStream;\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsReadFile: ( path: string, encoding?: string ) => Promise<string> = Bluebird.promisify( fs.readFile );\nlet fsWriteFile: ( path: string, data: string ) => Promise<string> = Bluebird.promisify( fs.writeFile );\nlet fsStat: ( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\nlet fsReadDirRecursively: ( path: string ) => Promise<string[]> = Bluebird.promisify( require( 'recursive-readdir' ) );\n\nexport interface IPatcherOptions\n{\n\tbrotli?: boolean;\n\ttempDir: string;\n\tarchiveListFile: string;\n}\n\nexport enum PatchHandleState\n{\n\tSTOPPED,\n\tPATCHING,\n\tFINISHED,\n}\n\nexport abstract class Patcher\n{\n\tstatic patch( from: string, to: string, options: IPatcherOptions ): PatchHandle\n\t{\n\t\treturn new PatchHandle( from, to, options );\n\t}\n}\n\nexport class PatchHandle\n{\n\tprivate _state: PatchHandleState;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tconstructor( private _from: string, private _to: string, private _options: IPatcherOptions )\n\t{\n\t\tthis._options = _.defaults<IPatcherOptions>( this._options || {}, {\n\t\t\tbrotli: true,\n\t\t} );\n\n\t\tthis._state = PatchHandleState.STOPPED;\n\t\tthis._emitter = new EventEmitter();\n\n\t\tthis._promise = this.promise;\n\n\t\tthis.patch()\n\t\t\t.then( () => this.onFinished() )\n\t\t\t.catch( ( err ) => this.onError( err ) );\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tprivate async patch()\n\t{\n\t\t// TODO: restrict operations to the given directories.\n\t\tthis._state = PatchHandleState.PATCHING;\n\n\t\tlet currentFiles: string[];\n\t\tif ( !( await fsExists( this._to ) ) || !( await fsStat( this._to ) ).isDirectory() ) {\n\t\t\tcurrentFiles = [];\n\t\t}\n\t\telse {\n\t\t\t// TODO: check if ./ is valid on windows platforms as well.\n\t\t\tcurrentFiles = ( await fsReadDirRecursively( this._to ) ).map( ( file ) => './' + path.relative( this._to, file ) );\n\t\t}\n\n\t\t// If the destination already exists, make sure its valid.\n\t\tlet exists = await fsExists( this._options.archiveListFile );\n\t\tif ( await fsExists( this._options.archiveListFile ) ) {\n\n\t\t\t// Make sure the destination is a file.\n\t\t\tlet stat = await fsStat( this._options.archiveListFile );\n\t\t\tif ( !stat.isFile() ) {\n\t\t\t\tthrow new Error( 'Can\\'t patch because the archive file list isn\\'t a file.' );\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we validate the folder path.\n\t\telse {\n\t\t\tlet archiveListFileDir = path.dirname( this._options.archiveListFile );\n\t\t\tif ( await fsExists( archiveListFileDir ) ) {\n\t\t\t\tlet dirStat = await fsStat( archiveListFileDir );\n\t\t\t\tif ( !dirStat.isDirectory() ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t patch because the path to the archive file list is invalid.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Create the folder path.\n\t\t\telse if ( !( await mkdirp( archiveListFileDir ) ) ) {\n\t\t\t\tthrow new Error( 'Couldn\\'t create the patch archive file list folder path' );\n\t\t\t}\n\t\t}\n\n\t\tlet oldBuildFiles;\n\t\tif ( !( await fsExists( this._options.archiveListFile ) ) ) {\n\t\t\toldBuildFiles = currentFiles;\n\t\t}\n\t\telse {\n\t\t\toldBuildFiles = ( await fsReadFile( this._options.archiveListFile, 'utf8' ) ).split( \"\\n\" );\n\t\t}\n\n\t\tlet extractResult = await Extractor.extract( this._from, this._to, {\n\t\t\tbrotli: this._options.brotli,\n\t\t\toverwrite: true,\n\t\t\tdeleteSource: true,\n\t\t} ).promise;\n\n\t\tif ( !extractResult.success ) {\n\t\t\tthrow new Error( 'Failed to extract patch file' );\n\t\t}\n\n\t\tlet newBuildFiles = extractResult.files;\n\n\t\t// Files that the old build created are files in the file system that are not listed in the old build files\n\t\tlet createdByOldBuild = _.difference( currentFiles, oldBuildFiles );\n\n\t\t// Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n\t\tlet filesToRemove = _.difference( currentFiles, newBuildFiles, createdByOldBuild );\n\n\t\t// TODO: use del lib\n\t\tlet unlinks = await Promise.all( filesToRemove.map( ( file ) =>\n\t\t{\n\t\t\treturn fsUnlink( path.resolve( this._to, file ) ).then( function( err )\n\t\t\t{\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t} ) );\n\n\t\tawait fsWriteFile( this._options.archiveListFile, newBuildFiles.join( \"\\n\" ) );\n\t\treturn true;\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis._state = PatchHandleState.STOPPED;\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis._state = PatchHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}