{"version":3,"sources":["patcher/index.js","patcher/index.ts"],"names":["PatchHandleState","Patcher","Patcher.patch","PatchHandle","PatchHandle.constructor","PatchHandle._getDecompressStream","PatchHandle.start","PatchHandle.stop","PatchHandle.patch","PatchHandle.onDownloading","PatchHandle.onProgress","PatchHandle.onPatching","PatchHandle.emitProgress","PatchHandle.onError","PatchHandle.onFinished","PatchHandle.promise"],"mappings":"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","file":"patcher/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar path = require('path');\nvar events_1 = require('events');\nvar StreamSpeed = require('../downloader/stream-speed');\nvar downloader_1 = require('../downloader');\nvar extractor_1 = require('../extractor');\nlet brotliDecompress = require('iltorb').decompressStream;\nlet gzipDecompress = require('gunzip-maybe');\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsReadFile = Bluebird.promisify(fs.readFile);\nlet fsWriteFile = Bluebird.promisify(fs.writeFile);\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nlet fsReadDirRecursively = Bluebird.promisify(require('recursive-readdir'));\n(function (PatchHandleState) {\n    PatchHandleState[PatchHandleState[\"STOPPED\"] = 0] = \"STOPPED\";\n    PatchHandleState[PatchHandleState[\"STOPPING\"] = 1] = \"STOPPING\";\n    PatchHandleState[PatchHandleState[\"DOWNLOADING\"] = 2] = \"DOWNLOADING\";\n    PatchHandleState[PatchHandleState[\"PATCHING\"] = 3] = \"PATCHING\";\n    PatchHandleState[PatchHandleState[\"FINISHED\"] = 4] = \"FINISHED\";\n})(exports.PatchHandleState || (exports.PatchHandleState = {}));\nvar PatchHandleState = exports.PatchHandleState;\nclass Patcher {\n    static patch(url, build, options) {\n        return new PatchHandle(url, build, options);\n    }\n}\nexports.Patcher = Patcher;\nclass PatchHandle {\n    constructor(_url, _build, _options) {\n        this._url = _url;\n        this._build = _build;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            decompressInDownload: true,\n        });\n        this._state = PatchHandleState.STOPPED;\n        this._downloadHandle = null;\n        this._emitter = new events_1.EventEmitter();\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    _getDecompressStream() {\n        if (!this._build.archive_type) {\n            return null;\n        }\n        switch (this._build.archive_type) {\n            case 'tar.gz':\n                return gzipDecompress();\n            case 'brotli':\n                return brotliDecompress();\n            default:\n                return null;\n        }\n    }\n    start() {\n        if (this._state !== PatchHandleState.STOPPED) {\n            return this;\n        }\n        this._promise = this.promise;\n        this._state = PatchHandleState.DOWNLOADING;\n        this._emitter.emit('downloading');\n        this._tempFile = path.join(this._build.install_dir, 'tempDownload');\n        this._archiveListFile = path.join(this._build.install_dir, 'archive-file-list');\n        this._to = path.join(this._build.install_dir, 'game');\n        if (!this._downloadHandle) {\n            this._downloadHandle = downloader_1.Downloader.download(this._url, this._tempFile, {\n                decompressStream: this._options.decompressInDownload ? this._getDecompressStream() : null,\n            });\n        }\n        this._downloadHandle.onProgress(StreamSpeed.SampleUnit.Bps, (progress) => this.emitProgress(progress))\n            .promise\n            .then(() => this.patch())\n            .then(() => this.onFinished())\n            .catch((err) => this.onError(err));\n        return this;\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== PatchHandleState.DOWNLOADING) {\n                return false;\n            }\n            this._state = PatchHandleState.STOPPING;\n            if (!(yield this._downloadHandle.stop())) {\n                this._state = PatchHandleState.DOWNLOADING;\n                return false;\n            }\n            this._state = PatchHandleState.STOPPED;\n            return true;\n        });\n    }\n    patch() {\n        return __awaiter(this, void 0, Promise, function* () {\n            // TODO: restrict operations to the given directories.\n            this._state = PatchHandleState.PATCHING;\n            this._emitter.emit('patching');\n            let currentFiles;\n            if (!(yield fsExists(this._to)) || !(yield fsStat(this._to)).isDirectory()) {\n                currentFiles = [];\n            }\n            else {\n                // TODO: check if ./ is valid on windows platforms as well.\n                currentFiles = (yield fsReadDirRecursively(this._to)).map((file) => './' + path.relative(this._to, file));\n            }\n            // If the destination already exists, make sure its valid.\n            if (yield fsExists(this._archiveListFile)) {\n                // Make sure the destination is a file.\n                let stat = yield fsStat(this._archiveListFile);\n                if (!stat.isFile()) {\n                    throw new Error('Can\\'t patch because the archive file list isn\\'t a file.');\n                }\n            }\n            else {\n                let archiveListFileDir = path.dirname(this._archiveListFile);\n                if (yield fsExists(archiveListFileDir)) {\n                    let dirStat = yield fsStat(archiveListFileDir);\n                    if (!dirStat.isDirectory()) {\n                        throw new Error('Can\\'t patch because the path to the archive file list is invalid.');\n                    }\n                }\n                else if (!(yield mkdirp(archiveListFileDir))) {\n                    throw new Error('Couldn\\'t create the patch archive file list folder path');\n                }\n            }\n            let oldBuildFiles;\n            if (!(yield fsExists(this._archiveListFile))) {\n                oldBuildFiles = currentFiles;\n            }\n            else {\n                oldBuildFiles = (yield fsReadFile(this._archiveListFile, 'utf8')).split(\"\\n\");\n            }\n            let extractResult = yield extractor_1.Extractor.extract(this._tempFile, this._to, {\n                overwrite: true,\n                deleteSource: true,\n                decompressStream: this._options.decompressInDownload ? null : this._getDecompressStream(),\n            }).promise;\n            if (!extractResult.success) {\n                throw new Error('Failed to extract patch file');\n            }\n            let newBuildFiles = extractResult.files;\n            // Files that the old build created are files in the file system that are not listed in the old build files\n            let createdByOldBuild = _.difference(currentFiles, oldBuildFiles);\n            // Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n            let filesToRemove = _.difference(currentFiles, newBuildFiles, createdByOldBuild);\n            // TODO: use del lib\n            let unlinks = yield Promise.all(filesToRemove.map((file) => {\n                return fsUnlink(path.resolve(this._to, file)).then(function (err) {\n                    if (err) {\n                        throw err;\n                    }\n                    return true;\n                });\n            }));\n            yield fsWriteFile(this._archiveListFile, newBuildFiles.join(\"\\n\"));\n            return true;\n        });\n    }\n    onDownloading(fn) {\n        this._emitter.addListener('downloading', fn);\n        return this;\n    }\n    onProgress(unit, fn) {\n        this._emitter.addListener('progress', (progress) => {\n            progress.sample = StreamSpeed.StreamSpeed.convertSample(progress.sample, unit);\n            fn(progress);\n        });\n        return this;\n    }\n    onPatching(fn) {\n        this._emitter.addListener('patching', fn);\n        return this;\n    }\n    emitProgress(progress) {\n        this._emitter.emit('progress', progress);\n    }\n    onError(err) {\n        this._state = PatchHandleState.STOPPED;\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this._state = PatchHandleState.FINISHED;\n        this._resolver();\n    }\n}\nexports.PatchHandle = PatchHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-fs';\nimport * as path from 'path';\nimport { Transform } from 'stream';\nimport { EventEmitter } from 'events';\n\nimport * as StreamSpeed from '../downloader/stream-speed';\nimport { Downloader, DownloadHandle, IDownloadProgress } from '../downloader';\nimport { Extractor } from '../extractor';\n\nlet brotliDecompress = require( 'iltorb' ).decompressStream;\nlet gzipDecompress = require( 'gunzip-maybe' );\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsReadFile: ( path: string, encoding?: string ) => Promise<string> = Bluebird.promisify( fs.readFile );\nlet fsWriteFile: ( path: string, data: string ) => Promise<string> = Bluebird.promisify( fs.writeFile );\nlet fsStat: ( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\nlet fsReadDirRecursively: ( path: string ) => Promise<string[]> = Bluebird.promisify( require( 'recursive-readdir' ) );\n\nexport interface IPatcherOptions\n{\n\tdecompressInDownload?: boolean;\n}\n\nexport enum PatchHandleState\n{\n\tSTOPPED,\n\tSTOPPING,\n\tDOWNLOADING,\n\tPATCHING,\n\tFINISHED,\n}\n\nexport abstract class Patcher\n{\n\tstatic patch( url: string, build: GameJolt.IGameBuild, options?: IPatcherOptions ): PatchHandle\n\t{\n\t\treturn new PatchHandle( url, build, options );\n\t}\n}\n\nexport class PatchHandle\n{\n\tprivate _state: PatchHandleState;\n\tprivate _to: string;\n\tprivate _tempFile: string;\n\tprivate _archiveListFile: string;\n\tprivate _downloadHandle: DownloadHandle;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tconstructor( private _url: string, private _build: GameJolt.IGameBuild, private _options?: IPatcherOptions )\n\t{\n\t\tthis._options = _.defaults<IPatcherOptions>( this._options || {}, {\n\t\t\tdecompressInDownload: true,\n\t\t} );\n\n\t\tthis._state = PatchHandleState.STOPPED;\n\t\tthis._downloadHandle = null;\n\t\tthis._emitter = new EventEmitter();\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tprivate _getDecompressStream()\n\t{\n\t\tif ( !this._build.archive_type ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch ( this._build.archive_type ) {\n\t\t\tcase 'tar.gz':\n\t\t\t\treturn gzipDecompress();\n\n\t\t\tcase 'brotli':\n\t\t\t\treturn brotliDecompress();\n\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tstart()\n\t{\n\t\tif ( this._state !== PatchHandleState.STOPPED ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._promise = this.promise;\n\n\t\tthis._state = PatchHandleState.DOWNLOADING;\n\t\tthis._emitter.emit( 'downloading' );\n\n\t\tthis._tempFile = path.join( this._build.install_dir, 'tempDownload' );\n\t\tthis._archiveListFile = path.join( this._build.install_dir, 'archive-file-list' );\n\t\tthis._to = path.join( this._build.install_dir, 'game' );\n\n\t\tif ( !this._downloadHandle ) {\n\t\t\tthis._downloadHandle = Downloader.download( this._url, this._tempFile, {\n\t\t\t\tdecompressStream: this._options.decompressInDownload ? this._getDecompressStream() : null,\n\t\t\t} );\n\t\t}\n\n\t\tthis._downloadHandle.onProgress( StreamSpeed.SampleUnit.Bps, ( progress ) => this.emitProgress( progress ) )\n\t\t\t.promise\n\t\t\t\t.then( () => this.patch() )\n\t\t\t\t.then( () => this.onFinished() )\n\t\t\t\t.catch( ( err ) => this.onError( err ) );\n\n\t\treturn this;\n\t}\n\n\tasync stop()\n\t{\n\t\tif ( this._state !== PatchHandleState.DOWNLOADING ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = PatchHandleState.STOPPING;\n\n\t\tif ( !( await this._downloadHandle.stop() ) ) {\n\t\t\tthis._state = PatchHandleState.DOWNLOADING;\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = PatchHandleState.STOPPED;\n\n\t\treturn true;\n\t}\n\n\tprivate async patch()\n\t{\n\t\t// TODO: restrict operations to the given directories.\n\t\tthis._state = PatchHandleState.PATCHING;\n\t\tthis._emitter.emit( 'patching' );\n\n\t\tlet currentFiles: string[];\n\t\tif ( !( await fsExists( this._to ) ) || !( await fsStat( this._to ) ).isDirectory() ) {\n\t\t\tcurrentFiles = [];\n\t\t}\n\t\telse {\n\t\t\t// TODO: check if ./ is valid on windows platforms as well.\n\t\t\tcurrentFiles = ( await fsReadDirRecursively( this._to ) ).map( ( file ) => './' + path.relative( this._to, file ) );\n\t\t}\n\n\t\t// If the destination already exists, make sure its valid.\n\t\tif ( await fsExists( this._archiveListFile ) ) {\n\n\t\t\t// Make sure the destination is a file.\n\t\t\tlet stat = await fsStat( this._archiveListFile );\n\t\t\tif ( !stat.isFile() ) {\n\t\t\t\tthrow new Error( 'Can\\'t patch because the archive file list isn\\'t a file.' );\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we validate the folder path.\n\t\telse {\n\t\t\tlet archiveListFileDir = path.dirname( this._archiveListFile );\n\t\t\tif ( await fsExists( archiveListFileDir ) ) {\n\t\t\t\tlet dirStat = await fsStat( archiveListFileDir );\n\t\t\t\tif ( !dirStat.isDirectory() ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t patch because the path to the archive file list is invalid.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Create the folder path.\n\t\t\telse if ( !( await mkdirp( archiveListFileDir ) ) ) {\n\t\t\t\tthrow new Error( 'Couldn\\'t create the patch archive file list folder path' );\n\t\t\t}\n\t\t}\n\n\t\tlet oldBuildFiles;\n\t\tif ( !( await fsExists( this._archiveListFile ) ) ) {\n\t\t\toldBuildFiles = currentFiles;\n\t\t}\n\t\telse {\n\t\t\toldBuildFiles = ( await fsReadFile( this._archiveListFile, 'utf8' ) ).split( \"\\n\" );\n\t\t}\n\n\t\tlet extractResult = await Extractor.extract( this._tempFile, this._to, {\n\t\t\toverwrite: true,\n\t\t\tdeleteSource: true,\n\t\t\tdecompressStream: this._options.decompressInDownload ? null : this._getDecompressStream(),\n\t\t} ).promise;\n\n\t\tif ( !extractResult.success ) {\n\t\t\tthrow new Error( 'Failed to extract patch file' );\n\t\t}\n\n\t\tlet newBuildFiles = extractResult.files;\n\n\t\t// Files that the old build created are files in the file system that are not listed in the old build files\n\t\tlet createdByOldBuild = _.difference( currentFiles, oldBuildFiles );\n\n\t\t// Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n\t\tlet filesToRemove = _.difference( currentFiles, newBuildFiles, createdByOldBuild );\n\n\t\t// TODO: use del lib\n\t\tlet unlinks = await Promise.all( filesToRemove.map( ( file ) =>\n\t\t{\n\t\t\treturn fsUnlink( path.resolve( this._to, file ) ).then( function( err )\n\t\t\t{\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t} ) );\n\n\t\tawait fsWriteFile( this._archiveListFile, newBuildFiles.join( \"\\n\" ) );\n\t\treturn true;\n\t}\n\n\tonDownloading( fn: Function ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'downloading', fn );\n\t\treturn this;\n\t}\n\n\tonProgress( unit: StreamSpeed.SampleUnit, fn: ( progress: IDownloadProgress ) => any ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', ( progress: IDownloadProgress ) =>\n\t\t{\n\t\t\tprogress.sample =  StreamSpeed.StreamSpeed.convertSample( progress.sample, unit );\n\t\t\tfn( progress );\n\t\t} );\n\t\treturn this;\n\t}\n\n\tonPatching( fn: Function ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'patching', fn );\n\t\treturn this;\n\t}\n\n\tprivate emitProgress( progress: IDownloadProgress )\n\t{\n\t\tthis._emitter.emit( 'progress', progress );\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis._state = PatchHandleState.STOPPED;\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis._state = PatchHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}