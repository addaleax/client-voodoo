{"version":3,"sources":["patcher/index.js","patcher/index.ts"],"names":["PatchHandleState","Patcher","Patcher.patch","PatchHandle","PatchHandle.constructor","PatchHandle._getDecompressStream","PatchHandle.waitForStart","PatchHandle.start","PatchHandle._stop","PatchHandle.stop","PatchHandle.cancel","PatchHandle.patch","PatchHandle.onDownloading","PatchHandle.onProgress","PatchHandle.onPatching","PatchHandle.emitProgress","PatchHandle.onError","PatchHandle.onFinished","PatchHandle.promise"],"mappings":"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","file":"patcher/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar path = require('path');\nvar events_1 = require('events');\nvar StreamSpeed = require('../downloader/stream-speed');\nvar downloader_1 = require('../downloader');\nvar extractor_1 = require('../extractor');\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsReadFile = Bluebird.promisify(fs.readFile);\nlet fsWriteFile = Bluebird.promisify(fs.writeFile);\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nlet fsReadDirRecursively = Bluebird.promisify(require('recursive-readdir'));\n(function (PatchHandleState) {\n    PatchHandleState[PatchHandleState[\"STOPPED_DOWNLOAD\"] = 0] = \"STOPPED_DOWNLOAD\";\n    PatchHandleState[PatchHandleState[\"STOPPING_DOWNLOAD\"] = 1] = \"STOPPING_DOWNLOAD\";\n    PatchHandleState[PatchHandleState[\"DOWNLOADING\"] = 2] = \"DOWNLOADING\";\n    PatchHandleState[PatchHandleState[\"STOPPED_PATCH\"] = 3] = \"STOPPED_PATCH\";\n    PatchHandleState[PatchHandleState[\"STOPPING_PATCH\"] = 4] = \"STOPPING_PATCH\";\n    PatchHandleState[PatchHandleState[\"PATCHING\"] = 5] = \"PATCHING\";\n    PatchHandleState[PatchHandleState[\"FINISHING\"] = 6] = \"FINISHING\";\n    PatchHandleState[PatchHandleState[\"FINISHED\"] = 7] = \"FINISHED\";\n})(exports.PatchHandleState || (exports.PatchHandleState = {}));\nvar PatchHandleState = exports.PatchHandleState;\nclass Patcher {\n    static patch(url, build, options) {\n        return new PatchHandle(url, build, options);\n    }\n}\nexports.Patcher = Patcher;\nclass PatchHandle {\n    constructor(_url, _build, _options) {\n        this._url = _url;\n        this._build = _build;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            overwrite: false,\n            decompressInDownload: false,\n        });\n        this._state = PatchHandleState.STOPPED_DOWNLOAD;\n        this._downloadHandle = null;\n        this._extractHandle = null;\n        this._emitter = new events_1.EventEmitter();\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    _getDecompressStream() {\n        if (!this._build.archive_type) {\n            return null;\n        }\n        switch (this._build.archive_type) {\n            case 'tar.xz':\n                return require('lzma-native').createDecompressor();\n            case 'tar.gz':\n                return require('gunzip-maybe')();\n            case 'brotli':\n                throw new Error('Not supporting brotli anymore.');\n            default:\n                throw new Error('No decompression given');\n        }\n    }\n    waitForStart() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== PatchHandleState.STOPPED_DOWNLOAD && this._state !== PatchHandleState.STOPPED_PATCH) {\n                return;\n            }\n            if (!this._waitForStartPromise) {\n                this._waitForStartPromise = new Promise((resolve, reject) => {\n                    this._waitForStartResolver = resolve;\n                    this._waitForStartRejector = reject;\n                });\n            }\n            return this._waitForStartPromise;\n        });\n    }\n    start(url) {\n        return __awaiter(this, void 0, Promise, function* () {\n            this._url = url || this._url;\n            this._promise = this.promise;\n            if (this._state === PatchHandleState.STOPPED_DOWNLOAD) {\n                if (this._waitForStartPromise) {\n                    this._waitForStartResolver();\n                    this._waitForStartPromise = null;\n                }\n                this._state = PatchHandleState.DOWNLOADING;\n                if (!this._emittedDownloading) {\n                    this._emitter.emit('downloading');\n                    this._emittedDownloading = true;\n                }\n                this._tempFile = path.join(this._build.install_dir, '.gj-tempDownload');\n                this._archiveListFile = path.join(this._build.install_dir, '.gj-archive-file-list');\n                this._patchListFile = path.join(this._build.install_dir, '.gj-patch-file');\n                this._to = this._build.install_dir;\n                if (!this._downloadHandle) {\n                    this._downloadHandle = downloader_1.Downloader.download(this._url, this._tempFile, {\n                        overwrite: this._options.overwrite,\n                        decompressStream: this._options.decompressInDownload ? this._getDecompressStream() : null,\n                    });\n                    // Make sure to not remove the temp download file if we're resuming.\n                    this._options.overwrite = false;\n                }\n                this._downloadHandle.onProgress(StreamSpeed.SampleUnit.Bps, (progress) => this.emitProgress(progress))\n                    .promise\n                    .then(() => this.patch())\n                    .then(() => this.onFinished())\n                    .catch((err) => this.onError(err));\n                return true;\n            }\n            else if (this._state === PatchHandleState.STOPPED_PATCH) {\n                if (this._waitForStartPromise) {\n                    this._waitForStartResolver();\n                    this._waitForStartPromise = null;\n                }\n                this._state = PatchHandleState.PATCHING;\n                this._extractHandle.start();\n                return true;\n            }\n            return false;\n        });\n    }\n    _stop(terminate) {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state === PatchHandleState.DOWNLOADING) {\n                this._state = PatchHandleState.STOPPING_DOWNLOAD;\n                if (!(yield this._downloadHandle.stop())) {\n                    this._state = PatchHandleState.DOWNLOADING;\n                    return false;\n                }\n                this._state = PatchHandleState.STOPPED_DOWNLOAD;\n            }\n            else if (this._state === PatchHandleState.PATCHING) {\n                this._state = PatchHandleState.STOPPING_PATCH;\n                if (!(yield this._extractHandle.stop(terminate))) {\n                    this._state = PatchHandleState.PATCHING;\n                    return false;\n                }\n                this._state = PatchHandleState.STOPPED_PATCH;\n            }\n            else {\n                return false;\n            }\n            if (terminate) {\n                this._emitter.emit('canceled');\n            }\n            else {\n                this._emitter.emit('stopped');\n            }\n            this.waitForStart();\n            return true;\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            return this._stop(false);\n        });\n    }\n    cancel() {\n        return __awaiter(this, void 0, Promise, function* () {\n            return this._stop(true);\n        });\n    }\n    patch() {\n        return __awaiter(this, void 0, Promise, function* () {\n            // TODO: restrict operations to the given directories.\n            this._state = PatchHandleState.PATCHING;\n            if (!this._emittedPatching) {\n                this._emitter.emit('patching');\n                this._emittedPatching = true;\n            }\n            let createdByOldBuild;\n            // TODO: check if ./ is valid on windows platforms as well.\n            let currentFiles = (yield fsReadDirRecursively(this._to))\n                .filter((file) => {\n                return !path.basename(file).startsWith('.gj-');\n            })\n                .map((file) => {\n                return './' + path.relative(this._to, file);\n            });\n            // If the patch file already exists, make sure its valid.\n            if (yield fsExists(this._patchListFile)) {\n                // Make sure the destination is a file.\n                let stat = yield fsStat(this._patchListFile);\n                if (!stat.isFile()) {\n                    throw new Error('Can\\'t patch because the patch file isn\\'t a file.');\n                }\n                createdByOldBuild = (yield fsReadFile(this._patchListFile, 'utf8')).split(\"\\n\");\n            }\n            else {\n                // If the destination already exists, make sure its valid.\n                if (yield fsExists(this._archiveListFile)) {\n                    // Make sure the destination is a file.\n                    let stat = yield fsStat(this._archiveListFile);\n                    if (!stat.isFile()) {\n                        throw new Error('Can\\'t patch because the archive file list isn\\'t a file.');\n                    }\n                }\n                else {\n                    let archiveListFileDir = path.dirname(this._archiveListFile);\n                    if (yield fsExists(archiveListFileDir)) {\n                        let dirStat = yield fsStat(archiveListFileDir);\n                        if (!dirStat.isDirectory()) {\n                            throw new Error('Can\\'t patch because the path to the archive file list is invalid.');\n                        }\n                    }\n                    else if (!(yield mkdirp(archiveListFileDir))) {\n                        throw new Error('Couldn\\'t create the patch archive file list folder path');\n                    }\n                }\n                let oldBuildFiles;\n                if (!(yield fsExists(this._archiveListFile))) {\n                    oldBuildFiles = currentFiles;\n                }\n                else {\n                    oldBuildFiles = (yield fsReadFile(this._archiveListFile, 'utf8')).split(\"\\n\");\n                }\n                // Files that the old build created are files in the file system that are not listed in the old build files\n                let createdByOldBuild = _.difference(currentFiles, oldBuildFiles);\n                yield fsWriteFile(this._patchListFile, createdByOldBuild.join(\"\\n\"));\n            }\n            this._extractHandle = yield this.waitForStart().then(() => extractor_1.Extractor.extract(this._tempFile, this._to, {\n                overwrite: true,\n                deleteSource: true,\n                decompressStream: this._options.decompressInDownload ? null : this._getDecompressStream(),\n            }));\n            let extractResult = yield this._extractHandle.promise;\n            if (!extractResult.success) {\n                throw new Error('Failed to extract patch file');\n            }\n            this._state = PatchHandleState.FINISHING;\n            let newBuildFiles = extractResult.files;\n            // Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n            let filesToRemove = _.difference(currentFiles, newBuildFiles, createdByOldBuild);\n            // TODO: use del lib\n            let unlinks = yield Promise.all(filesToRemove.map((file) => {\n                return fsUnlink(path.resolve(this._to, file)).then(function (err) {\n                    if (err) {\n                        throw err;\n                    }\n                    return true;\n                });\n            }));\n            yield fsWriteFile(this._archiveListFile, newBuildFiles.join(\"\\n\"));\n            return true;\n        });\n    }\n    onDownloading(fn) {\n        this._emitter.addListener('downloading', fn);\n        return this;\n    }\n    onProgress(unit, fn) {\n        this._emitter.addListener('progress', (progress) => {\n            progress.sample = StreamSpeed.StreamSpeed.convertSample(progress.sample, unit);\n            fn(progress);\n        });\n        return this;\n    }\n    onPatching(fn) {\n        this._emitter.addListener('patching', fn);\n        return this;\n    }\n    emitProgress(progress) {\n        this._emitter.emit('progress', progress);\n    }\n    onError(err) {\n        this._state = PatchHandleState.STOPPED_DOWNLOAD;\n        this._rejector(err);\n        this._promise = null;\n    }\n    onFinished() {\n        this._state = PatchHandleState.FINISHED;\n        this._resolver();\n    }\n}\nexports.PatchHandle = PatchHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-fs';\nimport * as path from 'path';\nimport { Transform } from 'stream';\nimport { EventEmitter } from 'events';\n\nimport * as StreamSpeed from '../downloader/stream-speed';\nimport { Downloader, DownloadHandle, IDownloadProgress } from '../downloader';\nimport { Extractor, ExtractHandle } from '../extractor';\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsReadFile: ( path: string, encoding?: string ) => Promise<string> = Bluebird.promisify( fs.readFile );\nlet fsWriteFile: ( path: string, data: string ) => Promise<string> = Bluebird.promisify( fs.writeFile );\nlet fsStat: ( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\nlet fsReadDirRecursively: ( path: string ) => Promise<string[]> = Bluebird.promisify( require( 'recursive-readdir' ) );\n\nexport interface IPatcherOptions\n{\n\toverwrite?: boolean;\n\tdecompressInDownload?: boolean;\n}\n\nexport enum PatchHandleState\n{\n\tSTOPPED_DOWNLOAD,\n\tSTOPPING_DOWNLOAD,\n\tDOWNLOADING,\n\tSTOPPED_PATCH,\n\tSTOPPING_PATCH,\n\tPATCHING,\n\tFINISHING,\n\tFINISHED,\n}\n\nexport abstract class Patcher\n{\n\tstatic patch( url: string, build: GameJolt.IGameBuild, options?: IPatcherOptions ): PatchHandle\n\t{\n\t\treturn new PatchHandle( url, build, options );\n\t}\n}\n\nexport class PatchHandle\n{\n\tprivate _state: PatchHandleState;\n\tprivate _to: string;\n\tprivate _tempFile: string;\n\tprivate _archiveListFile: string;\n\tprivate _patchListFile: string;\n\tprivate _downloadHandle: DownloadHandle;\n\tprivate _extractHandle: ExtractHandle;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tprivate _emittedDownloading: boolean;\n\tprivate _emittedPatching: boolean;\n\tprivate _waitForStartPromise: Promise<void>;\n\tprivate _waitForStartResolver: () => void;\n\tprivate _waitForStartRejector: ( err: NodeJS.ErrnoException ) => void;\n\n\tconstructor( private _url: string, private _build: GameJolt.IGameBuild, private _options?: IPatcherOptions )\n\t{\n\t\tthis._options = _.defaults<IPatcherOptions>( this._options || {}, {\n\t\t\toverwrite: false,\n\t\t\tdecompressInDownload: false,\n\t\t} );\n\n\t\tthis._state = PatchHandleState.STOPPED_DOWNLOAD;\n\t\tthis._downloadHandle = null;\n\t\tthis._extractHandle = null;\n\t\tthis._emitter = new EventEmitter();\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tprivate _getDecompressStream()\n\t{\n\t\tif ( !this._build.archive_type ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch ( this._build.archive_type ) {\n\t\t\tcase 'tar.xz':\n\t\t\t\treturn require( 'lzma-native' ).createDecompressor();\n\n\t\t\tcase 'tar.gz':\n\t\t\t\treturn require( 'gunzip-maybe' )();\n\n\t\t\tcase 'brotli':\n\t\t\t\tthrow new Error( 'Not supporting brotli anymore.' );\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'No decompression given' );\n\t\t}\n\t}\n\n\tprivate async waitForStart()\n\t{\n\t\tif ( this._state !== PatchHandleState.STOPPED_DOWNLOAD && this._state !== PatchHandleState.STOPPED_PATCH ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( !this._waitForStartPromise ) {\n\t\t\tthis._waitForStartPromise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._waitForStartResolver = resolve;\n\t\t\t\tthis._waitForStartRejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._waitForStartPromise;\n\t}\n\n\tasync start( url?: string )\n\t{\n\t\tthis._url = url || this._url;\n\t\tthis._promise = this.promise;\n\n\t\tif ( this._state === PatchHandleState.STOPPED_DOWNLOAD ) {\n\t\t\tif ( this._waitForStartPromise ) {\n\t\t\t\tthis._waitForStartResolver();\n\t\t\t\tthis._waitForStartPromise = null;\n\t\t\t}\n\n\t\t\tthis._state = PatchHandleState.DOWNLOADING;\n\t\t\tif ( !this._emittedDownloading ) {\n\t\t\t\tthis._emitter.emit( 'downloading' );\n\t\t\t\tthis._emittedDownloading = true;\n\t\t\t}\n\n\t\t\tthis._tempFile = path.join( this._build.install_dir, '.gj-tempDownload' );\n\t\t\tthis._archiveListFile = path.join( this._build.install_dir, '.gj-archive-file-list' );\n\t\t\tthis._patchListFile = path.join( this._build.install_dir, '.gj-patch-file' );\n\t\t\tthis._to = this._build.install_dir;\n\n\t\t\tif ( !this._downloadHandle ) {\n\t\t\t\tthis._downloadHandle = Downloader.download( this._url, this._tempFile, {\n\t\t\t\t\toverwrite: this._options.overwrite,\n\t\t\t\t\tdecompressStream: this._options.decompressInDownload ? this._getDecompressStream() : null,\n\t\t\t\t} );\n\n\t\t\t\t// Make sure to not remove the temp download file if we're resuming.\n\t\t\t\tthis._options.overwrite = false;\n\t\t\t}\n\n\t\t\tthis._downloadHandle.onProgress( StreamSpeed.SampleUnit.Bps, ( progress ) => this.emitProgress( progress ) )\n\t\t\t\t.promise\n\t\t\t\t\t.then( () => this.patch() )\n\t\t\t\t\t.then( () => this.onFinished() )\n\t\t\t\t\t.catch( ( err ) => this.onError( err ) );\n\n\t\t\treturn true;\n\t\t}\n\t\telse if ( this._state === PatchHandleState.STOPPED_PATCH ) {\n\t\t\tif ( this._waitForStartPromise ) {\n\t\t\t\tthis._waitForStartResolver();\n\t\t\t\tthis._waitForStartPromise = null;\n\t\t\t}\n\n\t\t\tthis._state = PatchHandleState.PATCHING;\n\t\t\tthis._extractHandle.start();\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async _stop( terminate: boolean )\n\t{\n\t\tif ( this._state === PatchHandleState.DOWNLOADING ) {\n\t\t\tthis._state = PatchHandleState.STOPPING_DOWNLOAD;\n\n\t\t\tif ( !( await this._downloadHandle.stop() ) ) {\n\t\t\t\tthis._state = PatchHandleState.DOWNLOADING;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._state = PatchHandleState.STOPPED_DOWNLOAD;\n\t\t}\n\t\telse if ( this._state === PatchHandleState.PATCHING ) {\n\t\t\tthis._state = PatchHandleState.STOPPING_PATCH;\n\n\t\t\tif ( !( await this._extractHandle.stop( terminate ) ) ) {\n\t\t\t\tthis._state = PatchHandleState.PATCHING;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._state = PatchHandleState.STOPPED_PATCH;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( terminate ) {\n\t\t\tthis._emitter.emit( 'canceled' );\n\t\t}\n\t\telse {\n\t\t\tthis._emitter.emit( 'stopped' );\n\t\t}\n\t\tthis.waitForStart();\n\t\treturn true;\n\t}\n\n\tasync stop()\n\t{\n\t\treturn this._stop( false );\n\t}\n\n\tasync cancel()\n\t{\n\t\treturn this._stop( true );\n\t}\n\n\tprivate async patch()\n\t{\n\t\t// TODO: restrict operations to the given directories.\n\t\tthis._state = PatchHandleState.PATCHING;\n\t\tif ( !this._emittedPatching ) {\n\t\t\tthis._emitter.emit( 'patching' );\n\t\t\tthis._emittedPatching = true;\n\t\t}\n\n\t\tlet createdByOldBuild: string[];\n\n\t\t// TODO: check if ./ is valid on windows platforms as well.\n\t\tlet currentFiles = ( await fsReadDirRecursively( this._to ) )\n\t\t\t.filter( ( file ) =>\n\t\t\t{\n\t\t\t\treturn !path.basename( file ).startsWith( '.gj-' );\n\t\t\t} )\n\t\t\t.map( ( file ) =>\n\t\t\t{\n\t\t\t\treturn './' + path.relative( this._to, file );\n\t\t\t} );\n\n\t\t// If the patch file already exists, make sure its valid.\n\t\tif ( await fsExists( this._patchListFile ) ) {\n\n\t\t\t// Make sure the destination is a file.\n\t\t\tlet stat = await fsStat( this._patchListFile );\n\t\t\tif ( !stat.isFile() ) {\n\t\t\t\tthrow new Error( 'Can\\'t patch because the patch file isn\\'t a file.' );\n\t\t\t}\n\n\t\t\tcreatedByOldBuild = ( await fsReadFile( this._patchListFile, 'utf8' ) ).split( \"\\n\" );\n\t\t}\n\t\telse {\n\n\t\t\t// If the destination already exists, make sure its valid.\n\t\t\tif ( await fsExists( this._archiveListFile ) ) {\n\n\t\t\t\t// Make sure the destination is a file.\n\t\t\t\tlet stat = await fsStat( this._archiveListFile );\n\t\t\t\tif ( !stat.isFile() ) {\n\t\t\t\t\tthrow new Error( 'Can\\'t patch because the archive file list isn\\'t a file.' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, we validate the folder path.\n\t\t\telse {\n\t\t\t\tlet archiveListFileDir = path.dirname( this._archiveListFile );\n\t\t\t\tif ( await fsExists( archiveListFileDir ) ) {\n\t\t\t\t\tlet dirStat = await fsStat( archiveListFileDir );\n\t\t\t\t\tif ( !dirStat.isDirectory() ) {\n\t\t\t\t\t\tthrow new Error( 'Can\\'t patch because the path to the archive file list is invalid.' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create the folder path.\n\t\t\t\telse if ( !( await mkdirp( archiveListFileDir ) ) ) {\n\t\t\t\t\tthrow new Error( 'Couldn\\'t create the patch archive file list folder path' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet oldBuildFiles;\n\t\t\tif ( !( await fsExists( this._archiveListFile ) ) ) {\n\t\t\t\toldBuildFiles = currentFiles;\n\t\t\t}\n\t\t\telse {\n\t\t\t\toldBuildFiles = ( await fsReadFile( this._archiveListFile, 'utf8' ) ).split( \"\\n\" );\n\t\t\t}\n\n\t\t\t// Files that the old build created are files in the file system that are not listed in the old build files\n\t\t\tlet createdByOldBuild = _.difference( currentFiles, oldBuildFiles );\n\n\t\t\tawait fsWriteFile( this._patchListFile, createdByOldBuild.join( \"\\n\" ) );\n\t\t}\n\n\t\tthis._extractHandle = await this.waitForStart().then( () => Extractor.extract( this._tempFile, this._to, {\n\t\t\toverwrite: true,\n\t\t\tdeleteSource: true,\n\t\t\tdecompressStream: this._options.decompressInDownload ? null : this._getDecompressStream(),\n\t\t} ) );\n\n\t\tlet extractResult = await this._extractHandle.promise;\n\t\tif ( !extractResult.success ) {\n\t\t\tthrow new Error( 'Failed to extract patch file' );\n\t\t}\n\n\t\tthis._state = PatchHandleState.FINISHING;\n\t\tlet newBuildFiles = extractResult.files;\n\n\t\t// Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n\t\tlet filesToRemove = _.difference( currentFiles, newBuildFiles, createdByOldBuild );\n\n\t\t// TODO: use del lib\n\t\tlet unlinks = await Promise.all( filesToRemove.map( ( file ) =>\n\t\t{\n\t\t\treturn fsUnlink( path.resolve( this._to, file ) ).then( function( err )\n\t\t\t{\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t} ) );\n\n\t\tawait fsWriteFile( this._archiveListFile, newBuildFiles.join( \"\\n\" ) );\n\t\treturn true;\n\t}\n\n\tonDownloading( fn: Function ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'downloading', fn );\n\t\treturn this;\n\t}\n\n\tonProgress( unit: StreamSpeed.SampleUnit, fn: ( progress: IDownloadProgress ) => any ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', ( progress: IDownloadProgress ) =>\n\t\t{\n\t\t\tprogress.sample =  StreamSpeed.StreamSpeed.convertSample( progress.sample, unit );\n\t\t\tfn( progress );\n\t\t} );\n\t\treturn this;\n\t}\n\n\tonPatching( fn: Function ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'patching', fn );\n\t\treturn this;\n\t}\n\n\tprivate emitProgress( progress: IDownloadProgress )\n\t{\n\t\tthis._emitter.emit( 'progress', progress );\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis._state = PatchHandleState.STOPPED_DOWNLOAD;\n\t\tthis._rejector( err );\n\t\tthis._promise = null;\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis._state = PatchHandleState.FINISHED;\n\t\tthis._resolver();\n\t}\n}\n"],"sourceRoot":"../../src/"}