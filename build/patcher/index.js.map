{"version":3,"sources":["patcher/index.js","patcher/index.ts"],"names":["PatchHandleState","Patcher","Patcher.patch","PatchHandle","PatchHandle.constructor","PatchHandle.start","PatchHandle.stop","PatchHandle.patch","PatchHandle.onProgress","PatchHandle.emitProgress","PatchHandle.onError","PatchHandle.onFinished","PatchHandle.promise"],"mappings":"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","file":"patcher/index.js","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\nvar fs = require('fs');\nvar _ = require('lodash');\nvar path = require('path');\nvar events_1 = require('events');\nvar StreamSpeed = require('../downloader/stream-speed');\nvar downloader_1 = require('../downloader');\nvar extractor_1 = require('../extractor');\nlet decompressStream = require('iltorb').decompressStream;\nlet Bluebird = require('bluebird');\nlet mkdirp = Bluebird.promisify(require('mkdirp'));\nlet fsUnlink = Bluebird.promisify(fs.unlink);\nlet fsExists = function (path) {\n    return new Promise(function (resolve) {\n        fs.exists(path, resolve);\n    });\n};\nlet fsReadFile = Bluebird.promisify(fs.readFile);\nlet fsWriteFile = Bluebird.promisify(fs.writeFile);\nlet fsStat = Bluebird.promisify(fs.stat);\nlet fsReadDir = Bluebird.promisify(fs.readdir);\nlet fsReadDirRecursively = Bluebird.promisify(require('recursive-readdir'));\n(function (PatchHandleState) {\n    PatchHandleState[PatchHandleState[\"STOPPED\"] = 0] = \"STOPPED\";\n    PatchHandleState[PatchHandleState[\"STOPPING\"] = 1] = \"STOPPING\";\n    PatchHandleState[PatchHandleState[\"DOWNLOADING\"] = 2] = \"DOWNLOADING\";\n    PatchHandleState[PatchHandleState[\"PATCHING\"] = 3] = \"PATCHING\";\n    PatchHandleState[PatchHandleState[\"FINISHED\"] = 4] = \"FINISHED\";\n})(exports.PatchHandleState || (exports.PatchHandleState = {}));\nvar PatchHandleState = exports.PatchHandleState;\nclass Patcher {\n    static patch(from, to, options) {\n        return new PatchHandle(from, to, options);\n    }\n}\nexports.Patcher = Patcher;\nclass PatchHandle {\n    constructor(_from, _to, _options) {\n        this._from = _from;\n        this._to = _to;\n        this._options = _options;\n        this._options = _.defaults(this._options || {}, {\n            brotli: true,\n        });\n        this._state = PatchHandleState.STOPPED;\n        this._downloadHandle = null;\n        this._emitter = new events_1.EventEmitter();\n        this.start();\n    }\n    get promise() {\n        if (!this._promise) {\n            this._promise = new Promise((resolve, reject) => {\n                this._resolver = resolve;\n                this._rejector = reject;\n            });\n        }\n        return this._promise;\n    }\n    start() {\n        if (this._state !== PatchHandleState.STOPPED) {\n            return false;\n        }\n        this._promise = this.promise;\n        this._state = PatchHandleState.DOWNLOADING;\n        this._downloadHandle = this._downloadHandle || downloader_1.Downloader.download(this._from, this._options.tempDir, {\n            brotli: this._options.brotli,\n        });\n        this._downloadHandle.onProgress(StreamSpeed.SampleUnit.Bps, (progress) => this.emitProgress(progress))\n            .promise\n            .then(() => this.patch())\n            .then(() => this.onFinished())\n            .catch((err) => this.onError(err));\n        return true;\n    }\n    stop() {\n        return __awaiter(this, void 0, Promise, function* () {\n            if (this._state !== PatchHandleState.DOWNLOADING) {\n                return false;\n            }\n            this._state = PatchHandleState.STOPPING;\n            if (!(yield this._downloadHandle.stop())) {\n                this._state = PatchHandleState.DOWNLOADING;\n                return false;\n            }\n            this._state = PatchHandleState.STOPPED;\n            return true;\n        });\n    }\n    patch() {\n        return __awaiter(this, void 0, Promise, function* () {\n            // TODO: restrict operations to the given directories.\n            this._state = PatchHandleState.PATCHING;\n            let currentFiles;\n            if (!(yield fsExists(this._to)) || !(yield fsStat(this._to)).isDirectory()) {\n                currentFiles = [];\n            }\n            else {\n                // TODO: check if ./ is valid on windows platforms as well.\n                currentFiles = (yield fsReadDirRecursively(this._to)).map((file) => './' + path.relative(this._to, file));\n            }\n            console.log('Current files: ' + JSON.stringify(currentFiles));\n            let oldBuildFiles;\n            if (!(yield fsExists(this._options.archiveListFile))) {\n                oldBuildFiles = currentFiles;\n            }\n            else {\n                oldBuildFiles = (yield fsReadFile(this._options.archiveListFile, 'utf8')).split(\"\\n\");\n            }\n            console.log('Old files: ' + JSON.stringify(oldBuildFiles));\n            let extractResult = yield extractor_1.Extractor.extract(this._downloadHandle.toFullpath, this._to, {\n                brotli: false,\n                overwrite: true,\n            });\n            if (!extractResult.success) {\n                throw new Error('Failed to extract patch file');\n            }\n            let newBuildFiles = extractResult.files;\n            console.log('New files: ' + JSON.stringify(newBuildFiles));\n            // Files that the old build created are files in the file system that are not listed in the old build files\n            let createdByOldBuild = _.difference(currentFiles, oldBuildFiles);\n            console.log('Created by old files: ' + JSON.stringify(createdByOldBuild));\n            // Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n            let filesToRemove = _.difference(currentFiles, newBuildFiles, createdByOldBuild);\n            console.log('Removing ' + JSON.stringify(filesToRemove));\n            let unlinks = yield Promise.all(filesToRemove.map((file) => {\n                return fsUnlink(path.resolve(this._to, file)).then(function (err) {\n                    if (err) {\n                        throw err;\n                    }\n                    return true;\n                });\n            }));\n            yield fsWriteFile(this._options.archiveListFile, newBuildFiles.join(\"\\n\"));\n            return true;\n        });\n    }\n    onProgress(unit, fn) {\n        this._emitter.addListener('progress', (progress) => {\n            progress.sample = StreamSpeed.StreamSpeed.convertSample(progress.sample, unit);\n            fn(this._state, progress);\n        });\n        return this;\n    }\n    emitProgress(progress) {\n        this._emitter.emit('progress', this._state, progress);\n    }\n    onError(err) {\n        this.stop().then(() => {\n            this._state = PatchHandleState.STOPPED;\n            this._rejector(err);\n            this._promise = null;\n        });\n    }\n    onFinished() {\n        this.stop().then(() => {\n            this._state = PatchHandleState.FINISHED;\n            this._resolver();\n        });\n    }\n}\nexports.PatchHandle = PatchHandle;\n","import * as fs from 'fs';\nimport * as _ from 'lodash';\nimport * as tar from 'tar-fs';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\n\nimport * as StreamSpeed from '../downloader/stream-speed';\nimport { Downloader, DownloadHandle, IDownloadProgress } from '../downloader';\nimport { Extractor } from '../extractor';\n\nlet decompressStream = require( 'iltorb' ).decompressStream;\n\nlet Bluebird = require( 'bluebird' );\nlet mkdirp:( path: string, mode?: string ) => Promise<boolean> = Bluebird.promisify( require( 'mkdirp' ) );\nlet fsUnlink:( path: string ) => Promise<NodeJS.ErrnoException> = Bluebird.promisify( fs.unlink );\nlet fsExists = function( path: string ): Promise<boolean>\n{\n\treturn new Promise<boolean>( function( resolve )\n\t{\n\t\tfs.exists( path, resolve );\n\t} );\n}\nlet fsReadFile: ( path: string, encoding?: string ) => Promise<string> = Bluebird.promisify( fs.readFile );\nlet fsWriteFile: ( path: string, data: string ) => Promise<string> = Bluebird.promisify( fs.writeFile );\nlet fsStat: ( path: string ) => Promise<fs.Stats> = Bluebird.promisify( fs.stat );\nlet fsReadDir: ( path: string ) => Promise<string[]> = Bluebird.promisify( fs.readdir );\nlet fsReadDirRecursively: ( path: string ) => Promise<string[]> = Bluebird.promisify( require( 'recursive-readdir' ) );\n\nexport interface IPatcherOptions\n{\n\tbrotli?: boolean;\n\ttempDir: string;\n\tarchiveListFile: string;\n}\n\nexport enum PatchHandleState\n{\n\tSTOPPED,\n\tSTOPPING,\n\tDOWNLOADING,\n\tPATCHING,\n\tFINISHED,\n}\n\nexport abstract class Patcher\n{\n\tstatic patch( from: string, to: string, options: IPatcherOptions ): PatchHandle\n\t{\n\t\treturn new PatchHandle( from, to, options );\n\t}\n}\n\nexport class PatchHandle\n{\n\tprivate _state: PatchHandleState;\n\tprivate _downloadHandle: DownloadHandle;\n\n\tprivate _promise: Promise<void>;\n\tprivate _resolver: () => void;\n\tprivate _rejector: ( err: NodeJS.ErrnoException ) => void;\n\tprivate _emitter: EventEmitter;\n\n\tconstructor( private _from: string, private _to: string, private _options: IPatcherOptions )\n\t{\n\t\tthis._options = _.defaults<IPatcherOptions>( this._options || {}, {\n\t\t\tbrotli: true,\n\t\t} );\n\n\t\tthis._state = PatchHandleState.STOPPED;\n\t\tthis._downloadHandle = null;\n\t\tthis._emitter = new EventEmitter();\n\t\tthis.start();\n\t}\n\n\tget promise(): Promise<void>\n\t{\n\t\tif ( !this._promise ) {\n\t\t\tthis._promise = new Promise<void>( ( resolve, reject ) =>\n\t\t\t{\n\t\t\t\tthis._resolver = resolve;\n\t\t\t\tthis._rejector = reject;\n\t\t\t} );\n\t\t}\n\t\treturn this._promise;\n\t}\n\n\tstart()\n\t{\n\t\tif ( this._state !== PatchHandleState.STOPPED ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._promise = this.promise;\n\n\t\tthis._state = PatchHandleState.DOWNLOADING;\n\n\t\tthis._downloadHandle = this._downloadHandle || Downloader.download( this._from, this._options.tempDir, {\n\t\t\tbrotli: this._options.brotli,\n\t\t} );\n\t\tthis._downloadHandle.onProgress( StreamSpeed.SampleUnit.Bps, ( progress ) => this.emitProgress( progress ) )\n\t\t\t.promise\n\t\t\t\t.then( () => this.patch() )\n\t\t\t\t.then( () => this.onFinished() )\n\t\t\t\t.catch( ( err ) => this.onError( err ) );\n\n\t\treturn true;\n\t}\n\n\tasync stop()\n\t{\n\t\tif ( this._state !== PatchHandleState.DOWNLOADING ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = PatchHandleState.STOPPING;\n\n\t\tif ( !( await this._downloadHandle.stop() ) ) {\n\t\t\tthis._state = PatchHandleState.DOWNLOADING;\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._state = PatchHandleState.STOPPED;\n\n\t\treturn true;\n\t}\n\n\tprivate async patch()\n\t{\n\t\t// TODO: restrict operations to the given directories.\n\t\tthis._state = PatchHandleState.PATCHING;\n\n\t\tlet currentFiles: string[];\n\t\tif ( !( await fsExists( this._to ) ) || !( await fsStat( this._to ) ).isDirectory() ) {\n\t\t\tcurrentFiles = [];\n\t\t}\n\t\telse {\n\t\t\t// TODO: check if ./ is valid on windows platforms as well.\n\t\t\tcurrentFiles = ( await fsReadDirRecursively( this._to ) ).map( ( file ) => './' + path.relative( this._to, file ) );\n\t\t}\n\t\tconsole.log( 'Current files: ' + JSON.stringify( currentFiles ) );\n\n\t\tlet oldBuildFiles;\n\t\tif ( !( await fsExists( this._options.archiveListFile ) ) ) {\n\t\t\toldBuildFiles = currentFiles;\n\t\t}\n\t\telse {\n\t\t\toldBuildFiles = ( await fsReadFile( this._options.archiveListFile, 'utf8' ) ).split( \"\\n\" );\n\t\t}\n\t\tconsole.log( 'Old files: ' + JSON.stringify( oldBuildFiles ) );\n\n\n\t\tlet extractResult = await Extractor.extract( this._downloadHandle.toFullpath, this._to, {\n\t\t\tbrotli: false,\n\t\t\toverwrite: true,\n\t\t} );\n\n\t\tif ( !extractResult.success ) {\n\t\t\tthrow new Error( 'Failed to extract patch file' );\n\t\t}\n\n\t\tlet newBuildFiles = extractResult.files;\n\t\tconsole.log( 'New files: ' + JSON.stringify( newBuildFiles ) );\n\n\t\t// Files that the old build created are files in the file system that are not listed in the old build files\n\t\tlet createdByOldBuild = _.difference( currentFiles, oldBuildFiles );\n\t\tconsole.log( 'Created by old files: ' + JSON.stringify( createdByOldBuild ) );\n\n\t\t// Files that need to be removed are files in fs that dont exist in the new build and were not created dynamically by the old build\n\t\tlet filesToRemove = _.difference( currentFiles, newBuildFiles, createdByOldBuild );\n\t\tconsole.log( 'Removing ' + JSON.stringify( filesToRemove ) );\n\n\t\tlet unlinks = await Promise.all( filesToRemove.map( ( file ) =>\n\t\t{\n\t\t\treturn fsUnlink( path.resolve( this._to, file ) ).then( function( err )\n\t\t\t{\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t} ) );\n\n\t\tawait fsWriteFile( this._options.archiveListFile, newBuildFiles.join( \"\\n\" ) );\n\t\treturn true;\n\t}\n\n\tonProgress( unit: StreamSpeed.SampleUnit, fn: ( state: PatchHandleState, progress?: IDownloadProgress ) => void ): PatchHandle\n\t{\n\t\tthis._emitter.addListener( 'progress', ( progress: IDownloadProgress ) =>\n\t\t{\n\t\t\tprogress.sample =  StreamSpeed.StreamSpeed.convertSample( progress.sample, unit );\n\t\t\tfn( this._state, progress );\n\t\t} );\n\t\treturn this;\n\t}\n\n\tprivate emitProgress( progress?: IDownloadProgress )\n\t{\n\t\tthis._emitter.emit( 'progress', this._state, progress );\n\t}\n\n\tprivate onError( err: NodeJS.ErrnoException )\n\t{\n\t\tthis.stop().then( () =>\n\t\t{\n\t\t\tthis._state = PatchHandleState.STOPPED;\n\t\t\tthis._rejector( err );\n\t\t\tthis._promise = null;\n\t\t} );\n\t}\n\n\tprivate onFinished()\n\t{\n\t\tthis.stop().then( () =>\n\t\t{\n\t\t\tthis._state = PatchHandleState.FINISHED;\n\t\t\tthis._resolver();\n\t\t} );\n\t}\n}\n"],"sourceRoot":"../../src/"}