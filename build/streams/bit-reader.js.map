{"version":3,"sources":["streams/bit-reader.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,IAAI,SAAS,GAAG,AAAC,aAAQ,UAAK,SAAS,IAAK,UAAU,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE;AAC3F,WAAO,IAAI,OAAO,CAAC,UAAU,OAAO,EAAE,MAAM,EAAE;AAC1C,iBAAS,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;AAChD,iBAAS,IAAI,CAAC,KAAK,EAAE;AAAE,mBAAO,KAAK,YAAY,OAAO,IAAI,KAAK,CAAC,WAAW,KAAK,OAAO,GAAG,KAAK,GAAG,IAAI,OAAO,CAAC,UAAU,OAAO,EAAE;AAAE,uBAAO,CAAC,KAAK,CAAC,CAAC;aAAE,CAAC,CAAC;SAAE;AACxJ,iBAAS,SAAS,CAAC,KAAK,EAAE;AAAE,gBAAI;AAAE,oBAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;aAAE,CAAC,OAAO,CAAC,EAAE;AAAE,sBAAM,CAAC,CAAC,CAAC,CAAC;aAAE;SAAE;AACnF,iBAAS,QAAQ,CAAC,KAAK,EAAE;AAAE,gBAAI;AAAE,oBAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAAE,CAAC,OAAO,CAAC,EAAE;AAAE,sBAAM,CAAC,CAAC,CAAC,CAAC;aAAE;SAAE;AACnF,iBAAS,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE;AACvB,gBAAI,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC;AACpC,kBAAM,CAAC,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;SACtF;AACD,YAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;KACxB,CAAC,CAAC;CACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAC","file":"streams/bit-reader.js","sourcesContent":["/*\nnode-bzip - a pure-javascript Node.JS module for decoding bzip2 data\n\nCopyright (C) 2012 Eli Skeggs\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, see\nhttp://www.gnu.org/licenses/lgpl-2.1.html\n\nAdapted from bzip2.js, copyright 2011 antimatter15 (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n*/\n// import { Readable } from 'stream';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, Promise, generator) {\n    return new Promise(function (resolve, reject) {\n        generator = generator.call(thisArg, _arguments);\n        function cast(value) { return value instanceof Promise && value.constructor === Promise ? value : new Promise(function (resolve) { resolve(value); }); }\n        function onfulfill(value) { try { step(\"next\", value); } catch (e) { reject(e); } }\n        function onreject(value) { try { step(\"throw\", value); } catch (e) { reject(e); } }\n        function step(verb, value) {\n            var result = generator[verb](value);\n            result.done ? resolve(result.value) : cast(result.value).then(onfulfill, onreject);\n        }\n        step(\"next\", void 0);\n    });\n};\n// const BITMASK = [0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n// // offset in bytes\n// class BitReader\n// {\n// \tprivate bitOffset: number;\n// \tprivate curByte: number;\n// \tprivate hasByte: boolean;\n// \tprivate queuedRead: Function;\n// \tconstructor( private stream: Readable )\n// \t{\n// \t\tthis.stream = stream;\n// \t\tthis.stream.on( 'readable', this._resume.bind( this ) );\n// \t\tthis.bitOffset = 0;\n// \t\tthis.curByte = 0;\n// \t\tthis.hasByte = false;\n// \t}\n// \tprivate _resume()\n// \t{\n// \t\tif ( this.queuedRead ) {\n// \t\t\tthis.curByte = this.stream.read( 1 );\n// \t\t\tthis.hasByte = true;\n// \t\t\tthis.queuedRead();\n// \t\t}\n// \t}\n// \tprivate _ensureBytes( bytes, cb )\n// \t{\n// \t\tif ( bytes && !this.hasByte ) {\n// \t\t\tthis.curByte = this.stream.read( bytes );\n// \t\t\tif ( this.curByte === null ) {\n// \t\t\t\tthis.queuedRead = cb;\n// \t\t\t}\n// \t\t\telse {\n// \t\t\t\tthis.hasByte = true;\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// reads bits from the buffer\n// \tread( bits: number )\n// \t{\n// \t\tlet result = 0;\n// \t\twhile ( bits > 0 ) {\n// \t\t\tlet missingBits = bits - 8 + this.bitOffset;\n// \t\t\tlet bytesToRequest = ( missingBits ) >> 3 + ( ( ( missingBits ) & 0x7 ) ? 1 : 0 );\n// \t\t\tif ( bytesToRequest ) {\n// \t\t\t\tthis._ensureBytes( bytesToRequest )\n// \t\t\t}\n// \t\t\telse {\n// \t\t\t\tresult <<= remaining;\n// \t\t\t\tresult |= BITMASK[remaining] & this.curByte;\n// \t\t\t\tthis.hasByte = false;\n// \t\t\t\tthis.bitOffset = 0;\n// \t\t\t\tbits -= remaining;\n// \t\t\t}\n// \t\t\tbytesToRequest && this._ensureBytes( bytesToRequest );\n// \t\t\tlet remaining = 8 - this.bitOffset;\n// \t\t\t// if we're in a byte\n// \t\t\tif (bits >= remaining) {\n// \t\t\t\tresult <<= remaining;\n// \t\t\t\tresult |= BITMASK[remaining] & this.curByte;\n// \t\t\t\tthis.hasByte = false;\n// \t\t\t\tthis.bitOffset = 0;\n// \t\t\t\tbits -= remaining;\n// \t\t\t}\n// \t\t\telse {\n// \t\t\t\tresult <<= bits;\n// \t\t\t\tlet shift = remaining - bits;\n// \t\t\t\tresult |= (this.curByte & (BITMASK[bits] << shift)) >> shift;\n// \t\t\t\tthis.bitOffset += bits;\n// \t\t\t\tbits = 0;\n// \t\t\t}\n// \t\t}\n// \t\treturn result;\n// \t}\n// \tprivate _read( )\n// }\n// // seek to an arbitrary point in the buffer (expressed in bits)\n// BitReader.prototype.seek = function(pos) {\n//   let n_bit = pos % 8;\n//   let n_byte = (pos - n_bit) / 8;\n//   this.bitOffset = n_bit;\n//   this.stream.seek(n_byte);\n//   this.hasByte = false;\n// };\n// // reads 6 bytes worth of data using the read method\n// BitReader.prototype.pi = function() {\n//   let buf = new Buffer(6), i;\n//   for (i = 0; i < buf.length; i++) {\n//     buf[i] = this.read(8);\n//   }\n//   return buf.toString('hex');\n// };\n// module.exports = BitReader;\n"],"sourceRoot":"../../src/"}